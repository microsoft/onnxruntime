// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_
#define FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace onnxruntime {
namespace fbs {

struct Shape;
struct ShapeBuilder;

struct Dimension;
struct DimensionBuilder;

struct DimensionValue;
struct DimensionValueBuilder;

struct TensorTypeAndShape;
struct TensorTypeAndShapeBuilder;

struct MapType;
struct MapTypeBuilder;

struct SequenceType;
struct SequenceTypeBuilder;

struct EdgeEnd;

struct NodeEdge;
struct NodeEdgeBuilder;

struct Node;
struct NodeBuilder;

struct ValueInfo;
struct ValueInfoBuilder;

struct TypeInfo;
struct TypeInfoBuilder;

struct OperatorSetId;
struct OperatorSetIdBuilder;

struct Tensor;
struct TensorBuilder;

struct SparseTensor;
struct SparseTensorBuilder;

struct Attribute;
struct AttributeBuilder;

struct NodesToOptimizeIndices;
struct NodesToOptimizeIndicesBuilder;

struct DeprecatedNodeIndexAndKernelDefHash;
struct DeprecatedNodeIndexAndKernelDefHashBuilder;

struct RuntimeOptimizationRecord;
struct RuntimeOptimizationRecordBuilder;

struct RuntimeOptimizationRecordContainerEntry;
struct RuntimeOptimizationRecordContainerEntryBuilder;

struct RuntimeOptimizations;
struct RuntimeOptimizationsBuilder;

struct Graph;
struct GraphBuilder;

struct StringStringEntry;
struct StringStringEntryBuilder;

struct Model;
struct ModelBuilder;

struct DeprecatedKernelCreateInfos;
struct DeprecatedKernelCreateInfosBuilder;

struct DeprecatedSubGraphSessionState;
struct DeprecatedSubGraphSessionStateBuilder;

struct DeprecatedSessionState;
struct DeprecatedSessionStateBuilder;

struct ArgTypeAndIndex;
struct ArgTypeAndIndexBuilder;

struct KernelTypeStrArgsEntry;
struct KernelTypeStrArgsEntryBuilder;

struct OpIdKernelTypeStrArgsEntry;
struct OpIdKernelTypeStrArgsEntryBuilder;

struct KernelTypeStrResolver;
struct KernelTypeStrResolverBuilder;

struct InferenceSession;
struct InferenceSessionBuilder;

enum class AttributeType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  MIN = UNDEFINED,
  MAX = SPARSE_TENSORS
};

inline const AttributeType (&EnumValuesAttributeType())[13] {
  static const AttributeType values[] = {
    AttributeType::UNDEFINED,
    AttributeType::FLOAT,
    AttributeType::INT,
    AttributeType::STRING,
    AttributeType::TENSOR,
    AttributeType::GRAPH,
    AttributeType::FLOATS,
    AttributeType::INTS,
    AttributeType::STRINGS,
    AttributeType::TENSORS,
    AttributeType::GRAPHS,
    AttributeType::SPARSE_TENSOR,
    AttributeType::SPARSE_TENSORS
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[14] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (flatbuffers::IsOutRange(e, AttributeType::UNDEFINED, AttributeType::SPARSE_TENSORS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum class DimensionValueType : int8_t {
  UNKNOWN = 0,
  VALUE = 1,
  PARAM = 2,
  MIN = UNKNOWN,
  MAX = PARAM
};

inline const DimensionValueType (&EnumValuesDimensionValueType())[3] {
  static const DimensionValueType values[] = {
    DimensionValueType::UNKNOWN,
    DimensionValueType::VALUE,
    DimensionValueType::PARAM
  };
  return values;
}

inline const char * const *EnumNamesDimensionValueType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "VALUE",
    "PARAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionValueType(DimensionValueType e) {
  if (flatbuffers::IsOutRange(e, DimensionValueType::UNKNOWN, DimensionValueType::PARAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionValueType()[index];
}

enum class TensorDataType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  FLOAT8E4M3FN = 17,
  FLOAT8E4M3FNUZ = 18,
  FLOAT8E5M2 = 19,
  FLOAT8E5M2FNUZ = 20,
  MIN = UNDEFINED,
  MAX = FLOAT8E5M2FNUZ
};

inline const TensorDataType (&EnumValuesTensorDataType())[21] {
  static const TensorDataType values[] = {
    TensorDataType::UNDEFINED,
    TensorDataType::FLOAT,
    TensorDataType::UINT8,
    TensorDataType::INT8,
    TensorDataType::UINT16,
    TensorDataType::INT16,
    TensorDataType::INT32,
    TensorDataType::INT64,
    TensorDataType::STRING,
    TensorDataType::BOOL,
    TensorDataType::FLOAT16,
    TensorDataType::DOUBLE,
    TensorDataType::UINT32,
    TensorDataType::UINT64,
    TensorDataType::COMPLEX64,
    TensorDataType::COMPLEX128,
    TensorDataType::BFLOAT16,
    TensorDataType::FLOAT8E4M3FN,
    TensorDataType::FLOAT8E4M3FNUZ,
    TensorDataType::FLOAT8E5M2,
    TensorDataType::FLOAT8E5M2FNUZ
  };
  return values;
}

inline const char * const *EnumNamesTensorDataType() {
  static const char * const names[22] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    "FLOAT8E4M3FN",
    "FLOAT8E4M3FNUZ",
    "FLOAT8E5M2",
    "FLOAT8E5M2FNUZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorDataType(TensorDataType e) {
  if (flatbuffers::IsOutRange(e, TensorDataType::UNDEFINED, TensorDataType::FLOAT8E5M2FNUZ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorDataType()[index];
}

enum class NodeType : int32_t {
  Primitive = 0,
  Fused = 1,
  MIN = Primitive,
  MAX = Fused
};

inline const NodeType (&EnumValuesNodeType())[2] {
  static const NodeType values[] = {
    NodeType::Primitive,
    NodeType::Fused
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[3] = {
    "Primitive",
    "Fused",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (flatbuffers::IsOutRange(e, NodeType::Primitive, NodeType::Fused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum class TypeInfoValue : uint8_t {
  NONE = 0,
  tensor_type = 1,
  sequence_type = 2,
  map_type = 3,
  MIN = NONE,
  MAX = map_type
};

inline const TypeInfoValue (&EnumValuesTypeInfoValue())[4] {
  static const TypeInfoValue values[] = {
    TypeInfoValue::NONE,
    TypeInfoValue::tensor_type,
    TypeInfoValue::sequence_type,
    TypeInfoValue::map_type
  };
  return values;
}

inline const char * const *EnumNamesTypeInfoValue() {
  static const char * const names[5] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeInfoValue(TypeInfoValue e) {
  if (flatbuffers::IsOutRange(e, TypeInfoValue::NONE, TypeInfoValue::map_type)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeInfoValue()[index];
}

template<typename T> struct TypeInfoValueTraits {
  static const TypeInfoValue enum_value = TypeInfoValue::NONE;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::TensorTypeAndShape> {
  static const TypeInfoValue enum_value = TypeInfoValue::tensor_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::SequenceType> {
  static const TypeInfoValue enum_value = TypeInfoValue::sequence_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::fbs::MapType> {
  static const TypeInfoValue enum_value = TypeInfoValue::map_type;
};

bool VerifyTypeInfoValue(flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type);
bool VerifyTypeInfoValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ArgType : int8_t {
  INPUT = 0,
  OUTPUT = 1,
  MIN = INPUT,
  MAX = OUTPUT
};

inline const ArgType (&EnumValuesArgType())[2] {
  static const ArgType values[] = {
    ArgType::INPUT,
    ArgType::OUTPUT
  };
  return values;
}

inline const char * const *EnumNamesArgType() {
  static const char * const names[3] = {
    "INPUT",
    "OUTPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameArgType(ArgType e) {
  if (flatbuffers::IsOutRange(e, ArgType::INPUT, ArgType::OUTPUT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArgType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EdgeEnd FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t node_index_;
  int32_t src_arg_index_;
  int32_t dst_arg_index_;

 public:
  EdgeEnd() {
    memset(static_cast<void *>(this), 0, sizeof(EdgeEnd));
  }
  EdgeEnd(uint32_t _node_index, int32_t _src_arg_index, int32_t _dst_arg_index)
      : node_index_(flatbuffers::EndianScalar(_node_index)),
        src_arg_index_(flatbuffers::EndianScalar(_src_arg_index)),
        dst_arg_index_(flatbuffers::EndianScalar(_dst_arg_index)) {
  }
  uint32_t node_index() const {
    return flatbuffers::EndianScalar(node_index_);
  }
  int32_t src_arg_index() const {
    return flatbuffers::EndianScalar(src_arg_index_);
  }
  int32_t dst_arg_index() const {
    return flatbuffers::EndianScalar(dst_arg_index_);
  }
};
FLATBUFFERS_STRUCT_END(EdgeEnd, 12);

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Dimension>> *dim() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Dimension>> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Dimension>>> dim) {
    fbb_.AddOffset(Shape::VT_DIM, dim);
  }
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Dimension>>> dim = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shape> CreateShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Dimension>> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Dimension>>(*dim) : 0;
  return onnxruntime::fbs::CreateShape(
      _fbb,
      dim__);
}

struct Dimension FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnxruntime::fbs::DimensionValue *value() const {
    return GetPointer<const onnxruntime::fbs::DimensionValue *>(VT_VALUE);
  }
  const flatbuffers::String *denotation() const {
    return GetPointer<const flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

struct DimensionBuilder {
  typedef Dimension Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value) {
    fbb_.AddOffset(Dimension::VT_VALUE, value);
  }
  void add_denotation(flatbuffers::Offset<flatbuffers::String> denotation) {
    fbb_.AddOffset(Dimension::VT_DENOTATION, denotation);
  }
  explicit DimensionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionBuilder &operator=(const DimensionBuilder &);
  flatbuffers::Offset<Dimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dimension>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dimension> CreateDimension(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value = 0,
    flatbuffers::Offset<flatbuffers::String> denotation = 0) {
  DimensionBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dimension> CreateDimensionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::DimensionValue> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::fbs::CreateDimension(
      _fbb,
      value,
      denotation__);
}

struct DimensionValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM_TYPE = 4,
    VT_DIM_VALUE = 6,
    VT_DIM_PARAM = 8
  };
  onnxruntime::fbs::DimensionValueType dim_type() const {
    return static_cast<onnxruntime::fbs::DimensionValueType>(GetField<int8_t>(VT_DIM_TYPE, 0));
  }
  int64_t dim_value() const {
    return GetField<int64_t>(VT_DIM_VALUE, 0);
  }
  const flatbuffers::String *dim_param() const {
    return GetPointer<const flatbuffers::String *>(VT_DIM_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DIM_TYPE) &&
           VerifyField<int64_t>(verifier, VT_DIM_VALUE) &&
           VerifyOffset(verifier, VT_DIM_PARAM) &&
           verifier.VerifyString(dim_param()) &&
           verifier.EndTable();
  }
};

struct DimensionValueBuilder {
  typedef DimensionValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim_type(onnxruntime::fbs::DimensionValueType dim_type) {
    fbb_.AddElement<int8_t>(DimensionValue::VT_DIM_TYPE, static_cast<int8_t>(dim_type), 0);
  }
  void add_dim_value(int64_t dim_value) {
    fbb_.AddElement<int64_t>(DimensionValue::VT_DIM_VALUE, dim_value, 0);
  }
  void add_dim_param(flatbuffers::Offset<flatbuffers::String> dim_param) {
    fbb_.AddOffset(DimensionValue::VT_DIM_PARAM, dim_param);
  }
  explicit DimensionValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionValueBuilder &operator=(const DimensionValueBuilder &);
  flatbuffers::Offset<DimensionValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionValue> CreateDimensionValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::DimensionValueType dim_type = onnxruntime::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    flatbuffers::Offset<flatbuffers::String> dim_param = 0) {
  DimensionValueBuilder builder_(_fbb);
  builder_.add_dim_value(dim_value);
  builder_.add_dim_param(dim_param);
  builder_.add_dim_type(dim_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionValue> CreateDimensionValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::DimensionValueType dim_type = onnxruntime::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    const char *dim_param = nullptr) {
  auto dim_param__ = dim_param ? _fbb.CreateString(dim_param) : 0;
  return onnxruntime::fbs::CreateDimensionValue(
      _fbb,
      dim_type,
      dim_value,
      dim_param__);
}

struct TensorTypeAndShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorTypeAndShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  onnxruntime::fbs::TensorDataType elem_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_ELEM_TYPE, 0));
  }
  const onnxruntime::fbs::Shape *shape() const {
    return GetPointer<const onnxruntime::fbs::Shape *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct TensorTypeAndShapeBuilder {
  typedef TensorTypeAndShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elem_type(onnxruntime::fbs::TensorDataType elem_type) {
    fbb_.AddElement<int32_t>(TensorTypeAndShape::VT_ELEM_TYPE, static_cast<int32_t>(elem_type), 0);
  }
  void add_shape(flatbuffers::Offset<onnxruntime::fbs::Shape> shape) {
    fbb_.AddOffset(TensorTypeAndShape::VT_SHAPE, shape);
  }
  explicit TensorTypeAndShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorTypeAndShapeBuilder &operator=(const TensorTypeAndShapeBuilder &);
  flatbuffers::Offset<TensorTypeAndShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorTypeAndShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorTypeAndShape> CreateTensorTypeAndShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::TensorDataType elem_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<onnxruntime::fbs::Shape> shape = 0) {
  TensorTypeAndShapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct MapType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_TYPE = 4,
    VT_VALUE_TYPE = 6
  };
  onnxruntime::fbs::TensorDataType key_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_KEY_TYPE, 0));
  }
  const onnxruntime::fbs::TypeInfo *value_type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_VALUE_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_TYPE) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           verifier.VerifyTable(value_type()) &&
           verifier.EndTable();
  }
};

struct MapTypeBuilder {
  typedef MapType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_type(onnxruntime::fbs::TensorDataType key_type) {
    fbb_.AddElement<int32_t>(MapType::VT_KEY_TYPE, static_cast<int32_t>(key_type), 0);
  }
  void add_value_type(flatbuffers::Offset<onnxruntime::fbs::TypeInfo> value_type) {
    fbb_.AddOffset(MapType::VT_VALUE_TYPE, value_type);
  }
  explicit MapTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapTypeBuilder &operator=(const MapTypeBuilder &);
  flatbuffers::Offset<MapType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapType>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapType> CreateMapType(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::TensorDataType key_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<onnxruntime::fbs::TypeInfo> value_type = 0) {
  MapTypeBuilder builder_(_fbb);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

struct SequenceType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4
  };
  const onnxruntime::fbs::TypeInfo *elem_type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_ELEM_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           verifier.VerifyTable(elem_type()) &&
           verifier.EndTable();
  }
};

struct SequenceTypeBuilder {
  typedef SequenceType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elem_type(flatbuffers::Offset<onnxruntime::fbs::TypeInfo> elem_type) {
    fbb_.AddOffset(SequenceType::VT_ELEM_TYPE, elem_type);
  }
  explicit SequenceTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceTypeBuilder &operator=(const SequenceTypeBuilder &);
  flatbuffers::Offset<SequenceType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceType>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceType> CreateSequenceType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::TypeInfo> elem_type = 0) {
  SequenceTypeBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct NodeEdge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeEdgeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDEX = 4,
    VT_INPUT_EDGES = 6,
    VT_OUTPUT_EDGES = 8
  };
  uint32_t node_index() const {
    return GetField<uint32_t>(VT_NODE_INDEX, 0);
  }
  const flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *input_edges() const {
    return GetPointer<const flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_INPUT_EDGES);
  }
  const flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *output_edges() const {
    return GetPointer<const flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *> *>(VT_OUTPUT_EDGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUT_EDGES) &&
           verifier.VerifyVector(input_edges()) &&
           VerifyOffset(verifier, VT_OUTPUT_EDGES) &&
           verifier.VerifyVector(output_edges()) &&
           verifier.EndTable();
  }
};

struct NodeEdgeBuilder {
  typedef NodeEdge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_index(uint32_t node_index) {
    fbb_.AddElement<uint32_t>(NodeEdge::VT_NODE_INDEX, node_index, 0);
  }
  void add_input_edges(flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> input_edges) {
    fbb_.AddOffset(NodeEdge::VT_INPUT_EDGES, input_edges);
  }
  void add_output_edges(flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> output_edges) {
    fbb_.AddOffset(NodeEdge::VT_OUTPUT_EDGES, output_edges);
  }
  explicit NodeEdgeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeEdgeBuilder &operator=(const NodeEdgeBuilder &);
  flatbuffers::Offset<NodeEdge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeEdge>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeEdge> CreateNodeEdge(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> input_edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::fbs::EdgeEnd *>> output_edges = 0) {
  NodeEdgeBuilder builder_(_fbb);
  builder_.add_output_edges(output_edges);
  builder_.add_input_edges(input_edges);
  builder_.add_node_index(node_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeEdge> CreateNodeEdgeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    const std::vector<onnxruntime::fbs::EdgeEnd> *input_edges = nullptr,
    const std::vector<onnxruntime::fbs::EdgeEnd> *output_edges = nullptr) {
  auto input_edges__ = input_edges ? _fbb.CreateVectorOfStructs<onnxruntime::fbs::EdgeEnd>(*input_edges) : 0;
  auto output_edges__ = output_edges ? _fbb.CreateVectorOfStructs<onnxruntime::fbs::EdgeEnd>(*output_edges) : 0;
  return onnxruntime::fbs::CreateNodeEdge(
      _fbb,
      node_index,
      input_edges__,
      output_edges__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DOMAIN = 8,
    VT_SINCE_VERSION = 10,
    VT_INDEX = 12,
    VT_OP_TYPE = 14,
    VT_TYPE = 16,
    VT_EXECUTION_PROVIDER_TYPE = 18,
    VT_INPUTS = 20,
    VT_OUTPUTS = 22,
    VT_ATTRIBUTES = 24,
    VT_INPUT_ARG_COUNTS = 26,
    VT_IMPLICIT_INPUTS = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int32_t since_version() const {
    return GetField<int32_t>(VT_SINCE_VERSION, 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *op_type() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_TYPE);
  }
  onnxruntime::fbs::NodeType type() const {
    return static_cast<onnxruntime::fbs::NodeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *execution_provider_type() const {
    return GetPointer<const flatbuffers::String *>(VT_EXECUTION_PROVIDER_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Attribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Attribute>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<int32_t> *input_arg_counts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_ARG_COUNTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *implicit_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IMPLICIT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int32_t>(verifier, VT_SINCE_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_OP_TYPE) &&
           verifier.VerifyString(op_type()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_EXECUTION_PROVIDER_TYPE) &&
           verifier.VerifyString(execution_provider_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_INPUT_ARG_COUNTS) &&
           verifier.VerifyVector(input_arg_counts()) &&
           VerifyOffset(verifier, VT_IMPLICIT_INPUTS) &&
           verifier.VerifyVector(implicit_inputs()) &&
           verifier.VerifyVectorOfStrings(implicit_inputs()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Node::VT_DOC_STRING, doc_string);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Node::VT_DOMAIN, domain);
  }
  void add_since_version(int32_t since_version) {
    fbb_.AddElement<int32_t>(Node::VT_SINCE_VERSION, since_version, 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Node::VT_INDEX, index, 0);
  }
  void add_op_type(flatbuffers::Offset<flatbuffers::String> op_type) {
    fbb_.AddOffset(Node::VT_OP_TYPE, op_type);
  }
  void add_type(onnxruntime::fbs::NodeType type) {
    fbb_.AddElement<int32_t>(Node::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_execution_provider_type(flatbuffers::Offset<flatbuffers::String> execution_provider_type) {
    fbb_.AddOffset(Node::VT_EXECUTION_PROVIDER_TYPE, execution_provider_type);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Node::VT_OUTPUTS, outputs);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Attribute>>> attributes) {
    fbb_.AddOffset(Node::VT_ATTRIBUTES, attributes);
  }
  void add_input_arg_counts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_arg_counts) {
    fbb_.AddOffset(Node::VT_INPUT_ARG_COUNTS, input_arg_counts);
  }
  void add_implicit_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicit_inputs) {
    fbb_.AddOffset(Node::VT_IMPLICIT_INPUTS, implicit_inputs);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int32_t since_version = 0,
    uint32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> op_type = 0,
    onnxruntime::fbs::NodeType type = onnxruntime::fbs::NodeType::Primitive,
    flatbuffers::Offset<flatbuffers::String> execution_provider_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Attribute>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_arg_counts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicit_inputs = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_implicit_inputs(implicit_inputs);
  builder_.add_input_arg_counts(input_arg_counts);
  builder_.add_attributes(attributes);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_execution_provider_type(execution_provider_type);
  builder_.add_type(type);
  builder_.add_op_type(op_type);
  builder_.add_index(index);
  builder_.add_since_version(since_version);
  builder_.add_domain(domain);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const char *domain = nullptr,
    int32_t since_version = 0,
    uint32_t index = 0,
    const char *op_type = nullptr,
    onnxruntime::fbs::NodeType type = onnxruntime::fbs::NodeType::Primitive,
    const char *execution_provider_type = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Attribute>> *attributes = nullptr,
    const std::vector<int32_t> *input_arg_counts = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *implicit_inputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto op_type__ = op_type ? _fbb.CreateString(op_type) : 0;
  auto execution_provider_type__ = execution_provider_type ? _fbb.CreateString(execution_provider_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Attribute>>(*attributes) : 0;
  auto input_arg_counts__ = input_arg_counts ? _fbb.CreateVector<int32_t>(*input_arg_counts) : 0;
  auto implicit_inputs__ = implicit_inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*implicit_inputs) : 0;
  return onnxruntime::fbs::CreateNode(
      _fbb,
      name__,
      doc_string__,
      domain__,
      since_version,
      index,
      op_type__,
      type,
      execution_provider_type__,
      inputs__,
      outputs__,
      attributes__,
      input_arg_counts__,
      implicit_inputs__);
}

struct ValueInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValueInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::fbs::TypeInfo *type() const {
    return GetPointer<const onnxruntime::fbs::TypeInfo *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

struct ValueInfoBuilder {
  typedef ValueInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ValueInfo::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(ValueInfo::VT_DOC_STRING, doc_string);
  }
  void add_type(flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type) {
    fbb_.AddOffset(ValueInfo::VT_TYPE, type);
  }
  explicit ValueInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValueInfoBuilder &operator=(const ValueInfoBuilder &);
  flatbuffers::Offset<ValueInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ValueInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ValueInfo> CreateValueInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type = 0) {
  ValueInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ValueInfo> CreateValueInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::TypeInfo> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  return onnxruntime::fbs::CreateValueInfo(
      _fbb,
      name__,
      doc_string__,
      type);
}

struct TypeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DENOTATION = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *denotation() const {
    return GetPointer<const flatbuffers::String *>(VT_DENOTATION);
  }
  onnxruntime::fbs::TypeInfoValue value_type() const {
    return static_cast<onnxruntime::fbs::TypeInfoValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const onnxruntime::fbs::TensorTypeAndShape *value_as_tensor_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::tensor_type ? static_cast<const onnxruntime::fbs::TensorTypeAndShape *>(value()) : nullptr;
  }
  const onnxruntime::fbs::SequenceType *value_as_sequence_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::sequence_type ? static_cast<const onnxruntime::fbs::SequenceType *>(value()) : nullptr;
  }
  const onnxruntime::fbs::MapType *value_as_map_type() const {
    return value_type() == onnxruntime::fbs::TypeInfoValue::map_type ? static_cast<const onnxruntime::fbs::MapType *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyTypeInfoValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const onnxruntime::fbs::TensorTypeAndShape *TypeInfo::value_as<onnxruntime::fbs::TensorTypeAndShape>() const {
  return value_as_tensor_type();
}

template<> inline const onnxruntime::fbs::SequenceType *TypeInfo::value_as<onnxruntime::fbs::SequenceType>() const {
  return value_as_sequence_type();
}

template<> inline const onnxruntime::fbs::MapType *TypeInfo::value_as<onnxruntime::fbs::MapType>() const {
  return value_as_map_type();
}

struct TypeInfoBuilder {
  typedef TypeInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_denotation(flatbuffers::Offset<flatbuffers::String> denotation) {
    fbb_.AddOffset(TypeInfo::VT_DENOTATION, denotation);
  }
  void add_value_type(onnxruntime::fbs::TypeInfoValue value_type) {
    fbb_.AddElement<uint8_t>(TypeInfo::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TypeInfo::VT_VALUE, value);
  }
  explicit TypeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TypeInfoBuilder &operator=(const TypeInfoBuilder &);
  flatbuffers::Offset<TypeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInfo> CreateTypeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> denotation = 0,
    onnxruntime::fbs::TypeInfoValue value_type = onnxruntime::fbs::TypeInfoValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  TypeInfoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_denotation(denotation);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeInfo> CreateTypeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *denotation = nullptr,
    onnxruntime::fbs::TypeInfoValue value_type = onnxruntime::fbs::TypeInfoValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::fbs::CreateTypeInfo(
      _fbb,
      denotation__,
      value_type,
      value);
}

struct OperatorSetId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorSetIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOMAIN = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct OperatorSetIdBuilder {
  typedef OperatorSetId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(OperatorSetId::VT_DOMAIN, domain);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(OperatorSetId::VT_VERSION, version, 0);
  }
  explicit OperatorSetIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorSetIdBuilder &operator=(const OperatorSetIdBuilder &);
  flatbuffers::Offset<OperatorSetId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorSetId>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int64_t version = 0) {
  OperatorSetIdBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_domain(domain);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorSetId> CreateOperatorSetIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain = nullptr,
    int64_t version = 0) {
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnxruntime::fbs::CreateOperatorSetId(
      _fbb,
      domain__,
      version);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DIMS = 8,
    VT_DATA_TYPE = 10,
    VT_RAW_DATA = 12,
    VT_STRING_DATA = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  onnxruntime::fbs::TensorDataType data_type() const {
    return static_cast<onnxruntime::fbs::TensorDataType>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *string_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRING_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_STRING_DATA) &&
           verifier.VerifyVector(string_data()) &&
           verifier.VerifyVectorOfStrings(string_data()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Tensor::VT_DOC_STRING, doc_string);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_data_type(onnxruntime::fbs::TensorDataType data_type) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_raw_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(Tensor::VT_RAW_DATA, raw_data);
  }
  void add_string_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_data) {
    fbb_.AddOffset(Tensor::VT_STRING_DATA, string_data);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0,
    onnxruntime::fbs::TensorDataType data_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_data = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_string_data(string_data);
  builder_.add_raw_data(raw_data);
  builder_.add_data_type(data_type);
  builder_.add_dims(dims);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const std::vector<int64_t> *dims = nullptr,
    onnxruntime::fbs::TensorDataType data_type = onnxruntime::fbs::TensorDataType::UNDEFINED,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *string_data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto string_data__ = string_data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*string_data) : 0;
  return onnxruntime::fbs::CreateTensor(
      _fbb,
      name__,
      doc_string__,
      dims__,
      data_type,
      raw_data__,
      string_data__);
}

struct SparseTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INDICES = 6,
    VT_DIMS = 8
  };
  const onnxruntime::fbs::Tensor *values() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_VALUES);
  }
  const onnxruntime::fbs::Tensor *indices() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_INDICES);
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyTable(values()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyTable(indices()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct SparseTensorBuilder {
  typedef SparseTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<onnxruntime::fbs::Tensor> values) {
    fbb_.AddOffset(SparseTensor::VT_VALUES, values);
  }
  void add_indices(flatbuffers::Offset<onnxruntime::fbs::Tensor> indices) {
    fbb_.AddOffset(SparseTensor::VT_INDICES, indices);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(SparseTensor::VT_DIMS, dims);
  }
  explicit SparseTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseTensorBuilder &operator=(const SparseTensorBuilder &);
  flatbuffers::Offset<SparseTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseTensor> CreateSparseTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> values = 0,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  SparseTensorBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_indices(indices);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparseTensor> CreateSparseTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> values = 0,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> indices = 0,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return onnxruntime::fbs::CreateSparseTensor(
      _fbb,
      values,
      indices,
      dims__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8,
    VT_F = 10,
    VT_I = 12,
    VT_S = 14,
    VT_T = 16,
    VT_G = 18,
    VT_FLOATS = 20,
    VT_INTS = 22,
    VT_STRINGS = 24,
    VT_TENSORS = 26,
    VT_GRAPHS = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  onnxruntime::fbs::AttributeType type() const {
    return static_cast<onnxruntime::fbs::AttributeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  int64_t i() const {
    return GetField<int64_t>(VT_I, 0);
  }
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  const onnxruntime::fbs::Tensor *t() const {
    return GetPointer<const onnxruntime::fbs::Tensor *>(VT_T);
  }
  const onnxruntime::fbs::Graph *g() const {
    return GetPointer<const onnxruntime::fbs::Graph *>(VT_G);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<int64_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Graph>> *graphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Graph>> *>(VT_GRAPHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_F) &&
           VerifyField<int64_t>(verifier, VT_I) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyTable(t()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyTable(g()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Attribute::VT_DOC_STRING, doc_string);
  }
  void add_type(onnxruntime::fbs::AttributeType type) {
    fbb_.AddElement<int32_t>(Attribute::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attribute::VT_F, f, 0.0f);
  }
  void add_i(int64_t i) {
    fbb_.AddElement<int64_t>(Attribute::VT_I, i, 0);
  }
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(Attribute::VT_S, s);
  }
  void add_t(flatbuffers::Offset<onnxruntime::fbs::Tensor> t) {
    fbb_.AddOffset(Attribute::VT_T, t);
  }
  void add_g(flatbuffers::Offset<onnxruntime::fbs::Graph> g) {
    fbb_.AddOffset(Attribute::VT_G, g);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attribute::VT_FLOATS, floats);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ints) {
    fbb_.AddOffset(Attribute::VT_INTS, ints);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attribute::VT_STRINGS, strings);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>> tensors) {
    fbb_.AddOffset(Attribute::VT_TENSORS, tensors);
  }
  void add_graphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Graph>>> graphs) {
    fbb_.AddOffset(Attribute::VT_GRAPHS, graphs);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeBuilder &operator=(const AttributeBuilder &);
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    onnxruntime::fbs::AttributeType type = onnxruntime::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> t = 0,
    flatbuffers::Offset<onnxruntime::fbs::Graph> g = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Graph>>> graphs = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_i(i);
  builder_.add_graphs(graphs);
  builder_.add_tensors(tensors);
  builder_.add_strings(strings);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_g(g);
  builder_.add_t(t);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    onnxruntime::fbs::AttributeType type = onnxruntime::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    const char *s = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::Tensor> t = 0,
    flatbuffers::Offset<onnxruntime::fbs::Graph> g = 0,
    const std::vector<float> *floats = nullptr,
    const std::vector<int64_t> *ints = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *strings = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *tensors = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Graph>> *graphs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int64_t>(*ints) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*strings) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>(*tensors) : 0;
  auto graphs__ = graphs ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Graph>>(*graphs) : 0;
  return onnxruntime::fbs::CreateAttribute(
      _fbb,
      name__,
      doc_string__,
      type,
      f,
      i,
      s__,
      t,
      g,
      floats__,
      ints__,
      strings__,
      tensors__,
      graphs__);
}

/// nodes to consider for a runtime optimization
/// see corresponding type in onnxruntime/core/graph/runtime_optimization_record.h
struct NodesToOptimizeIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodesToOptimizeIndicesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDICES = 4,
    VT_NUM_INPUTS = 6,
    VT_NUM_OUTPUTS = 8,
    VT_HAS_VARIADIC_INPUT = 10,
    VT_HAS_VARIADIC_OUTPUT = 12,
    VT_NUM_VARIADIC_INPUTS = 14,
    VT_NUM_VARIADIC_OUTPUTS = 16
  };
  const flatbuffers::Vector<uint32_t> *node_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  uint32_t num_inputs() const {
    return GetField<uint32_t>(VT_NUM_INPUTS, 0);
  }
  uint32_t num_outputs() const {
    return GetField<uint32_t>(VT_NUM_OUTPUTS, 0);
  }
  bool has_variadic_input() const {
    return GetField<uint8_t>(VT_HAS_VARIADIC_INPUT, 0) != 0;
  }
  bool has_variadic_output() const {
    return GetField<uint8_t>(VT_HAS_VARIADIC_OUTPUT, 0) != 0;
  }
  uint32_t num_variadic_inputs() const {
    return GetField<uint32_t>(VT_NUM_VARIADIC_INPUTS, 0);
  }
  uint32_t num_variadic_outputs() const {
    return GetField<uint32_t>(VT_NUM_VARIADIC_OUTPUTS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_INPUTS) &&
           VerifyField<uint32_t>(verifier, VT_NUM_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_HAS_VARIADIC_INPUT) &&
           VerifyField<uint8_t>(verifier, VT_HAS_VARIADIC_OUTPUT) &&
           VerifyField<uint32_t>(verifier, VT_NUM_VARIADIC_INPUTS) &&
           VerifyField<uint32_t>(verifier, VT_NUM_VARIADIC_OUTPUTS) &&
           verifier.EndTable();
  }
};

struct NodesToOptimizeIndicesBuilder {
  typedef NodesToOptimizeIndices Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices) {
    fbb_.AddOffset(NodesToOptimizeIndices::VT_NODE_INDICES, node_indices);
  }
  void add_num_inputs(uint32_t num_inputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_INPUTS, num_inputs, 0);
  }
  void add_num_outputs(uint32_t num_outputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_OUTPUTS, num_outputs, 0);
  }
  void add_has_variadic_input(bool has_variadic_input) {
    fbb_.AddElement<uint8_t>(NodesToOptimizeIndices::VT_HAS_VARIADIC_INPUT, static_cast<uint8_t>(has_variadic_input), 0);
  }
  void add_has_variadic_output(bool has_variadic_output) {
    fbb_.AddElement<uint8_t>(NodesToOptimizeIndices::VT_HAS_VARIADIC_OUTPUT, static_cast<uint8_t>(has_variadic_output), 0);
  }
  void add_num_variadic_inputs(uint32_t num_variadic_inputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_VARIADIC_INPUTS, num_variadic_inputs, 0);
  }
  void add_num_variadic_outputs(uint32_t num_variadic_outputs) {
    fbb_.AddElement<uint32_t>(NodesToOptimizeIndices::VT_NUM_VARIADIC_OUTPUTS, num_variadic_outputs, 0);
  }
  explicit NodesToOptimizeIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodesToOptimizeIndicesBuilder &operator=(const NodesToOptimizeIndicesBuilder &);
  flatbuffers::Offset<NodesToOptimizeIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodesToOptimizeIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices = 0,
    uint32_t num_inputs = 0,
    uint32_t num_outputs = 0,
    bool has_variadic_input = false,
    bool has_variadic_output = false,
    uint32_t num_variadic_inputs = 0,
    uint32_t num_variadic_outputs = 0) {
  NodesToOptimizeIndicesBuilder builder_(_fbb);
  builder_.add_num_variadic_outputs(num_variadic_outputs);
  builder_.add_num_variadic_inputs(num_variadic_inputs);
  builder_.add_num_outputs(num_outputs);
  builder_.add_num_inputs(num_inputs);
  builder_.add_node_indices(node_indices);
  builder_.add_has_variadic_output(has_variadic_output);
  builder_.add_has_variadic_input(has_variadic_input);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodesToOptimizeIndices> CreateNodesToOptimizeIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *node_indices = nullptr,
    uint32_t num_inputs = 0,
    uint32_t num_outputs = 0,
    bool has_variadic_input = false,
    bool has_variadic_output = false,
    uint32_t num_variadic_inputs = 0,
    uint32_t num_variadic_outputs = 0) {
  auto node_indices__ = node_indices ? _fbb.CreateVector<uint32_t>(*node_indices) : 0;
  return onnxruntime::fbs::CreateNodesToOptimizeIndices(
      _fbb,
      node_indices__,
      num_inputs,
      num_outputs,
      has_variadic_input,
      has_variadic_output,
      num_variadic_inputs,
      num_variadic_outputs);
}

/// deprecated: no longer using kernel def hashes
struct DeprecatedNodeIndexAndKernelDefHash FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeprecatedNodeIndexAndKernelDefHashBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDEX = 4,
    VT_KERNEL_DEF_HASH = 6
  };
  uint32_t node_index() const {
    return GetField<uint32_t>(VT_NODE_INDEX, 0);
  }
  uint64_t kernel_def_hash() const {
    return GetField<uint64_t>(VT_KERNEL_DEF_HASH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NODE_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_KERNEL_DEF_HASH) &&
           verifier.EndTable();
  }
};

struct DeprecatedNodeIndexAndKernelDefHashBuilder {
  typedef DeprecatedNodeIndexAndKernelDefHash Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_index(uint32_t node_index) {
    fbb_.AddElement<uint32_t>(DeprecatedNodeIndexAndKernelDefHash::VT_NODE_INDEX, node_index, 0);
  }
  void add_kernel_def_hash(uint64_t kernel_def_hash) {
    fbb_.AddElement<uint64_t>(DeprecatedNodeIndexAndKernelDefHash::VT_KERNEL_DEF_HASH, kernel_def_hash, 0);
  }
  explicit DeprecatedNodeIndexAndKernelDefHashBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeprecatedNodeIndexAndKernelDefHashBuilder &operator=(const DeprecatedNodeIndexAndKernelDefHashBuilder &);
  flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeprecatedNodeIndexAndKernelDefHash> CreateDeprecatedNodeIndexAndKernelDefHash(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    uint64_t kernel_def_hash = 0) {
  DeprecatedNodeIndexAndKernelDefHashBuilder builder_(_fbb);
  builder_.add_kernel_def_hash(kernel_def_hash);
  builder_.add_node_index(node_index);
  return builder_.Finish();
}

/// a single runtime optimization
/// see corresponding type in onnxruntime/core/graph/runtime_optimization_record.h
struct RuntimeOptimizationRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimeOptimizationRecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION_ID = 4,
    VT_NODES_TO_OPTIMIZE_INDICES = 6,
    VT_PRODUCED_OP_IDS = 10
  };
  const flatbuffers::String *action_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTION_ID);
  }
  const onnxruntime::fbs::NodesToOptimizeIndices *nodes_to_optimize_indices() const {
    return GetPointer<const onnxruntime::fbs::NodesToOptimizeIndices *>(VT_NODES_TO_OPTIMIZE_INDICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *produced_op_ids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PRODUCED_OP_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION_ID) &&
           verifier.VerifyString(action_id()) &&
           VerifyOffset(verifier, VT_NODES_TO_OPTIMIZE_INDICES) &&
           verifier.VerifyTable(nodes_to_optimize_indices()) &&
           VerifyOffset(verifier, VT_PRODUCED_OP_IDS) &&
           verifier.VerifyVector(produced_op_ids()) &&
           verifier.VerifyVectorOfStrings(produced_op_ids()) &&
           verifier.EndTable();
  }
};

struct RuntimeOptimizationRecordBuilder {
  typedef RuntimeOptimizationRecord Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action_id(flatbuffers::Offset<flatbuffers::String> action_id) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_ACTION_ID, action_id);
  }
  void add_nodes_to_optimize_indices(flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_NODES_TO_OPTIMIZE_INDICES, nodes_to_optimize_indices);
  }
  void add_produced_op_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> produced_op_ids) {
    fbb_.AddOffset(RuntimeOptimizationRecord::VT_PRODUCED_OP_IDS, produced_op_ids);
  }
  explicit RuntimeOptimizationRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuntimeOptimizationRecordBuilder &operator=(const RuntimeOptimizationRecordBuilder &);
  flatbuffers::Offset<RuntimeOptimizationRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimeOptimizationRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> action_id = 0,
    flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> produced_op_ids = 0) {
  RuntimeOptimizationRecordBuilder builder_(_fbb);
  builder_.add_produced_op_ids(produced_op_ids);
  builder_.add_nodes_to_optimize_indices(nodes_to_optimize_indices);
  builder_.add_action_id(action_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuntimeOptimizationRecord> CreateRuntimeOptimizationRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *action_id = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::NodesToOptimizeIndices> nodes_to_optimize_indices = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *produced_op_ids = nullptr) {
  auto action_id__ = action_id ? _fbb.CreateString(action_id) : 0;
  auto produced_op_ids__ = produced_op_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*produced_op_ids) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecord(
      _fbb,
      action_id__,
      nodes_to_optimize_indices,
      produced_op_ids__);
}

struct RuntimeOptimizationRecordContainerEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimeOptimizationRecordContainerEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIMIZER_NAME = 4,
    VT_RUNTIME_OPTIMIZATION_RECORDS = 6
  };
  const flatbuffers::String *optimizer_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OPTIMIZER_NAME);
  }
  bool KeyCompareLessThan(const RuntimeOptimizationRecordContainerEntry *o) const {
    return *optimizer_name() < *o->optimizer_name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(optimizer_name()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *runtime_optimization_records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *>(VT_RUNTIME_OPTIMIZATION_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OPTIMIZER_NAME) &&
           verifier.VerifyString(optimizer_name()) &&
           VerifyOffset(verifier, VT_RUNTIME_OPTIMIZATION_RECORDS) &&
           verifier.VerifyVector(runtime_optimization_records()) &&
           verifier.VerifyVectorOfTables(runtime_optimization_records()) &&
           verifier.EndTable();
  }
};

struct RuntimeOptimizationRecordContainerEntryBuilder {
  typedef RuntimeOptimizationRecordContainerEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_optimizer_name(flatbuffers::Offset<flatbuffers::String> optimizer_name) {
    fbb_.AddOffset(RuntimeOptimizationRecordContainerEntry::VT_OPTIMIZER_NAME, optimizer_name);
  }
  void add_runtime_optimization_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>> runtime_optimization_records) {
    fbb_.AddOffset(RuntimeOptimizationRecordContainerEntry::VT_RUNTIME_OPTIMIZATION_RECORDS, runtime_optimization_records);
  }
  explicit RuntimeOptimizationRecordContainerEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuntimeOptimizationRecordContainerEntryBuilder &operator=(const RuntimeOptimizationRecordContainerEntryBuilder &);
  flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry>(end);
    fbb_.Required(o, RuntimeOptimizationRecordContainerEntry::VT_OPTIMIZER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> optimizer_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>> runtime_optimization_records = 0) {
  RuntimeOptimizationRecordContainerEntryBuilder builder_(_fbb);
  builder_.add_runtime_optimization_records(runtime_optimization_records);
  builder_.add_optimizer_name(optimizer_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuntimeOptimizationRecordContainerEntry> CreateRuntimeOptimizationRecordContainerEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *optimizer_name = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>> *runtime_optimization_records = nullptr) {
  auto optimizer_name__ = optimizer_name ? _fbb.CreateString(optimizer_name) : 0;
  auto runtime_optimization_records__ = runtime_optimization_records ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecord>>(*runtime_optimization_records) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizationRecordContainerEntry(
      _fbb,
      optimizer_name__,
      runtime_optimization_records__);
}

struct RuntimeOptimizations FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RuntimeOptimizationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  /// mapping from optimizer name to [RuntimeOptimizationRecord]
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct RuntimeOptimizationsBuilder {
  typedef RuntimeOptimizations Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>>> records) {
    fbb_.AddOffset(RuntimeOptimizations::VT_RECORDS, records);
  }
  explicit RuntimeOptimizationsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RuntimeOptimizationsBuilder &operator=(const RuntimeOptimizationsBuilder &);
  flatbuffers::Offset<RuntimeOptimizations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RuntimeOptimizations>(end);
    return o;
  }
};

inline flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizations(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>>> records = 0) {
  RuntimeOptimizationsBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<RuntimeOptimizations> CreateRuntimeOptimizationsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::RuntimeOptimizationRecordContainerEntry>(records) : 0;
  return onnxruntime::fbs::CreateRuntimeOptimizations(
      _fbb,
      records__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITIALIZERS = 4,
    VT_NODE_ARGS = 6,
    VT_NODES = 8,
    VT_MAX_NODE_INDEX = 10,
    VT_NODE_EDGES = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS = 16,
    VT_SPARSE_INITIALIZERS = 18,
    VT_RUNTIME_OPTIMIZATIONS = 20
  };
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *node_args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *>(VT_NODE_ARGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Node>> *>(VT_NODES);
  }
  uint32_t max_node_index() const {
    return GetField<uint32_t>(VT_MAX_NODE_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *node_edges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *>(VT_NODE_EDGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *sparse_initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *>(VT_SPARSE_INITIALIZERS);
  }
  const onnxruntime::fbs::RuntimeOptimizations *runtime_optimizations() const {
    return GetPointer<const onnxruntime::fbs::RuntimeOptimizations *>(VT_RUNTIME_OPTIMIZATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_NODE_ARGS) &&
           verifier.VerifyVector(node_args()) &&
           verifier.VerifyVectorOfTables(node_args()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_NODE_INDEX) &&
           VerifyOffset(verifier, VT_NODE_EDGES) &&
           verifier.VerifyVector(node_edges()) &&
           verifier.VerifyVectorOfTables(node_edges()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_SPARSE_INITIALIZERS) &&
           verifier.VerifyVector(sparse_initializers()) &&
           verifier.VerifyVectorOfTables(sparse_initializers()) &&
           VerifyOffset(verifier, VT_RUNTIME_OPTIMIZATIONS) &&
           verifier.VerifyTable(runtime_optimizations()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>> initializers) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS, initializers);
  }
  void add_node_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>> node_args) {
    fbb_.AddOffset(Graph::VT_NODE_ARGS, node_args);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Node>>> nodes) {
    fbb_.AddOffset(Graph::VT_NODES, nodes);
  }
  void add_max_node_index(uint32_t max_node_index) {
    fbb_.AddElement<uint32_t>(Graph::VT_MAX_NODE_INDEX, max_node_index, 0);
  }
  void add_node_edges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>> node_edges) {
    fbb_.AddOffset(Graph::VT_NODE_EDGES, node_edges);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Graph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  void add_sparse_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>> sparse_initializers) {
    fbb_.AddOffset(Graph::VT_SPARSE_INITIALIZERS, sparse_initializers);
  }
  void add_runtime_optimizations(flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations) {
    fbb_.AddOffset(Graph::VT_RUNTIME_OPTIMIZATIONS, runtime_optimizations);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GraphBuilder &operator=(const GraphBuilder &);
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>> node_args = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::Node>>> nodes = 0,
    uint32_t max_node_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>> node_edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>> sparse_initializers = 0,
    flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_runtime_optimizations(runtime_optimizations);
  builder_.add_sparse_initializers(sparse_initializers);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_node_edges(node_edges);
  builder_.add_max_node_index(max_node_index);
  builder_.add_nodes(nodes);
  builder_.add_node_args(node_args);
  builder_.add_initializers(initializers);
  return builder_.Finish();
}

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Tensor>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>> *node_args = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::Node>> *nodes = nullptr,
    uint32_t max_node_index = 0,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>> *node_edges = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>> *sparse_initializers = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::RuntimeOptimizations> runtime_optimizations = 0) {
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Tensor>>(*initializers) : 0;
  auto node_args__ = node_args ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::ValueInfo>>(*node_args) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::Node>>(*nodes) : 0;
  auto node_edges__ = node_edges ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::NodeEdge>>(*node_edges) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  auto sparse_initializers__ = sparse_initializers ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::SparseTensor>>(*sparse_initializers) : 0;
  return onnxruntime::fbs::CreateGraph(
      _fbb,
      initializers__,
      node_args__,
      nodes__,
      max_node_index,
      node_edges__,
      inputs__,
      outputs__,
      sparse_initializers__,
      runtime_optimizations);
}

struct StringStringEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringStringEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringStringEntryBuilder {
  typedef StringStringEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(StringStringEntry::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringStringEntry::VT_VALUE, value);
  }
  explicit StringStringEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringStringEntryBuilder &operator=(const StringStringEntryBuilder &);
  flatbuffers::Offset<StringStringEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringStringEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringStringEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringStringEntry> CreateStringStringEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return onnxruntime::fbs::CreateStringStringEntry(
      _fbb,
      key__,
      value__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IR_VERSION = 4,
    VT_OPSET_IMPORT = 6,
    VT_PRODUCER_NAME = 8,
    VT_PRODUCER_VERSION = 10,
    VT_DOMAIN = 12,
    VT_MODEL_VERSION = 14,
    VT_DOC_STRING = 16,
    VT_GRAPH = 18,
    VT_GRAPH_DOC_STRING = 20,
    VT_METADATA_PROPS = 22
  };
  int64_t ir_version() const {
    return GetField<int64_t>(VT_IR_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *opset_import() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  const flatbuffers::String *producer_name() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  const flatbuffers::String *producer_version() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t model_version() const {
    return GetField<int64_t>(VT_MODEL_VERSION, 0);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::fbs::Graph *graph() const {
    return GetPointer<const onnxruntime::fbs::Graph *>(VT_GRAPH);
  }
  const flatbuffers::String *graph_doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPH_DOC_STRING);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *metadata_props() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IR_VERSION) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_PRODUCER_NAME) &&
           verifier.VerifyString(producer_name()) &&
           VerifyOffset(verifier, VT_PRODUCER_VERSION) &&
           verifier.VerifyString(producer_version()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_MODEL_VERSION) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_GRAPH) &&
           verifier.VerifyTable(graph()) &&
           VerifyOffset(verifier, VT_GRAPH_DOC_STRING) &&
           verifier.VerifyString(graph_doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ir_version(int64_t ir_version) {
    fbb_.AddElement<int64_t>(Model::VT_IR_VERSION, ir_version, 0);
  }
  void add_opset_import(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>> opset_import) {
    fbb_.AddOffset(Model::VT_OPSET_IMPORT, opset_import);
  }
  void add_producer_name(flatbuffers::Offset<flatbuffers::String> producer_name) {
    fbb_.AddOffset(Model::VT_PRODUCER_NAME, producer_name);
  }
  void add_producer_version(flatbuffers::Offset<flatbuffers::String> producer_version) {
    fbb_.AddOffset(Model::VT_PRODUCER_VERSION, producer_version);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Model::VT_DOMAIN, domain);
  }
  void add_model_version(int64_t model_version) {
    fbb_.AddElement<int64_t>(Model::VT_MODEL_VERSION, model_version, 0);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Model::VT_DOC_STRING, doc_string);
  }
  void add_graph(flatbuffers::Offset<onnxruntime::fbs::Graph> graph) {
    fbb_.AddOffset(Model::VT_GRAPH, graph);
  }
  void add_graph_doc_string(flatbuffers::Offset<flatbuffers::String> graph_doc_string) {
    fbb_.AddOffset(Model::VT_GRAPH_DOC_STRING, graph_doc_string);
  }
  void add_metadata_props(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Model::VT_METADATA_PROPS, metadata_props);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>> opset_import = 0,
    flatbuffers::Offset<flatbuffers::String> producer_name = 0,
    flatbuffers::Offset<flatbuffers::String> producer_version = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int64_t model_version = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<onnxruntime::fbs::Graph> graph = 0,
    flatbuffers::Offset<flatbuffers::String> graph_doc_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>> metadata_props = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_model_version(model_version);
  builder_.add_ir_version(ir_version);
  builder_.add_metadata_props(metadata_props);
  builder_.add_graph_doc_string(graph_doc_string);
  builder_.add_graph(graph);
  builder_.add_doc_string(doc_string);
  builder_.add_domain(domain);
  builder_.add_producer_version(producer_version);
  builder_.add_producer_name(producer_name);
  builder_.add_opset_import(opset_import);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>> *opset_import = nullptr,
    const char *producer_name = nullptr,
    const char *producer_version = nullptr,
    const char *domain = nullptr,
    int64_t model_version = 0,
    const char *doc_string = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::Graph> graph = 0,
    const char *graph_doc_string = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>> *metadata_props = nullptr) {
  auto opset_import__ = opset_import ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::OperatorSetId>>(*opset_import) : 0;
  auto producer_name__ = producer_name ? _fbb.CreateString(producer_name) : 0;
  auto producer_version__ = producer_version ? _fbb.CreateString(producer_version) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto graph_doc_string__ = graph_doc_string ? _fbb.CreateString(graph_doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::StringStringEntry>>(*metadata_props) : 0;
  return onnxruntime::fbs::CreateModel(
      _fbb,
      ir_version,
      opset_import__,
      producer_name__,
      producer_version__,
      domain__,
      model_version,
      doc_string__,
      graph,
      graph_doc_string__,
      metadata_props__);
}

/// deprecated: no longer using kernel def hashes
struct DeprecatedKernelCreateInfos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeprecatedKernelCreateInfosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDICES = 4,
    VT_KERNEL_DEF_HASHES = 6
  };
  const flatbuffers::Vector<uint32_t> *node_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  const flatbuffers::Vector<uint64_t> *kernel_def_hashes() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_KERNEL_DEF_HASHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyOffset(verifier, VT_KERNEL_DEF_HASHES) &&
           verifier.VerifyVector(kernel_def_hashes()) &&
           verifier.EndTable();
  }
};

struct DeprecatedKernelCreateInfosBuilder {
  typedef DeprecatedKernelCreateInfos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices) {
    fbb_.AddOffset(DeprecatedKernelCreateInfos::VT_NODE_INDICES, node_indices);
  }
  void add_kernel_def_hashes(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> kernel_def_hashes) {
    fbb_.AddOffset(DeprecatedKernelCreateInfos::VT_KERNEL_DEF_HASHES, kernel_def_hashes);
  }
  explicit DeprecatedKernelCreateInfosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeprecatedKernelCreateInfosBuilder &operator=(const DeprecatedKernelCreateInfosBuilder &);
  flatbuffers::Offset<DeprecatedKernelCreateInfos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeprecatedKernelCreateInfos>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfos(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> kernel_def_hashes = 0) {
  DeprecatedKernelCreateInfosBuilder builder_(_fbb);
  builder_.add_kernel_def_hashes(kernel_def_hashes);
  builder_.add_node_indices(node_indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeprecatedKernelCreateInfos> CreateDeprecatedKernelCreateInfosDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *node_indices = nullptr,
    const std::vector<uint64_t> *kernel_def_hashes = nullptr) {
  auto node_indices__ = node_indices ? _fbb.CreateVector<uint32_t>(*node_indices) : 0;
  auto kernel_def_hashes__ = kernel_def_hashes ? _fbb.CreateVector<uint64_t>(*kernel_def_hashes) : 0;
  return onnxruntime::fbs::CreateDeprecatedKernelCreateInfos(
      _fbb,
      node_indices__,
      kernel_def_hashes__);
}

/// deprecated: no longer using kernel def hashes
struct DeprecatedSubGraphSessionState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeprecatedSubGraphSessionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_ID = 4,
    VT_SESSION_STATE = 6
  };
  const flatbuffers::String *graph_id() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPH_ID);
  }
  bool KeyCompareLessThan(const DeprecatedSubGraphSessionState *o) const {
    return *graph_id() < *o->graph_id();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(graph_id()->c_str(), val);
  }
  const onnxruntime::fbs::DeprecatedSessionState *session_state() const {
    return GetPointer<const onnxruntime::fbs::DeprecatedSessionState *>(VT_SESSION_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPH_ID) &&
           verifier.VerifyString(graph_id()) &&
           VerifyOffset(verifier, VT_SESSION_STATE) &&
           verifier.VerifyTable(session_state()) &&
           verifier.EndTable();
  }
};

struct DeprecatedSubGraphSessionStateBuilder {
  typedef DeprecatedSubGraphSessionState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graph_id(flatbuffers::Offset<flatbuffers::String> graph_id) {
    fbb_.AddOffset(DeprecatedSubGraphSessionState::VT_GRAPH_ID, graph_id);
  }
  void add_session_state(flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state) {
    fbb_.AddOffset(DeprecatedSubGraphSessionState::VT_SESSION_STATE, session_state);
  }
  explicit DeprecatedSubGraphSessionStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeprecatedSubGraphSessionStateBuilder &operator=(const DeprecatedSubGraphSessionStateBuilder &);
  flatbuffers::Offset<DeprecatedSubGraphSessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeprecatedSubGraphSessionState>(end);
    fbb_.Required(o, DeprecatedSubGraphSessionState::VT_GRAPH_ID);
    return o;
  }
};

inline flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graph_id = 0,
    flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state = 0) {
  DeprecatedSubGraphSessionStateBuilder builder_(_fbb);
  builder_.add_session_state(session_state);
  builder_.add_graph_id(graph_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeprecatedSubGraphSessionState> CreateDeprecatedSubGraphSessionStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graph_id = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::DeprecatedSessionState> session_state = 0) {
  auto graph_id__ = graph_id ? _fbb.CreateString(graph_id) : 0;
  return onnxruntime::fbs::CreateDeprecatedSubGraphSessionState(
      _fbb,
      graph_id__,
      session_state);
}

/// deprecated: no longer using kernel def hashes
struct DeprecatedSessionState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeprecatedSessionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNELS = 4,
    VT_SUB_GRAPH_SESSION_STATES = 6
  };
  const onnxruntime::fbs::DeprecatedKernelCreateInfos *kernels() const {
    return GetPointer<const onnxruntime::fbs::DeprecatedKernelCreateInfos *>(VT_KERNELS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *sub_graph_session_states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *>(VT_SUB_GRAPH_SESSION_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyTable(kernels()) &&
           VerifyOffset(verifier, VT_SUB_GRAPH_SESSION_STATES) &&
           verifier.VerifyVector(sub_graph_session_states()) &&
           verifier.VerifyVectorOfTables(sub_graph_session_states()) &&
           verifier.EndTable();
  }
};

struct DeprecatedSessionStateBuilder {
  typedef DeprecatedSessionState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernels(flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels) {
    fbb_.AddOffset(DeprecatedSessionState::VT_KERNELS, kernels);
  }
  void add_sub_graph_session_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>>> sub_graph_session_states) {
    fbb_.AddOffset(DeprecatedSessionState::VT_SUB_GRAPH_SESSION_STATES, sub_graph_session_states);
  }
  explicit DeprecatedSessionStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeprecatedSessionStateBuilder &operator=(const DeprecatedSessionStateBuilder &);
  flatbuffers::Offset<DeprecatedSessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeprecatedSessionState>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>>> sub_graph_session_states = 0) {
  DeprecatedSessionStateBuilder builder_(_fbb);
  builder_.add_sub_graph_session_states(sub_graph_session_states);
  builder_.add_kernels(kernels);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeprecatedSessionState> CreateDeprecatedSessionStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::fbs::DeprecatedKernelCreateInfos> kernels = 0,
    std::vector<flatbuffers::Offset<onnxruntime::fbs::DeprecatedSubGraphSessionState>> *sub_graph_session_states = nullptr) {
  auto sub_graph_session_states__ = sub_graph_session_states ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::DeprecatedSubGraphSessionState>(sub_graph_session_states) : 0;
  return onnxruntime::fbs::CreateDeprecatedSessionState(
      _fbb,
      kernels,
      sub_graph_session_states__);
}

struct ArgTypeAndIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgTypeAndIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARG_TYPE = 4,
    VT_INDEX = 6
  };
  onnxruntime::fbs::ArgType arg_type() const {
    return static_cast<onnxruntime::fbs::ArgType>(GetField<int8_t>(VT_ARG_TYPE, 0));
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ARG_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct ArgTypeAndIndexBuilder {
  typedef ArgTypeAndIndex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arg_type(onnxruntime::fbs::ArgType arg_type) {
    fbb_.AddElement<int8_t>(ArgTypeAndIndex::VT_ARG_TYPE, static_cast<int8_t>(arg_type), 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(ArgTypeAndIndex::VT_INDEX, index, 0);
  }
  explicit ArgTypeAndIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgTypeAndIndexBuilder &operator=(const ArgTypeAndIndexBuilder &);
  flatbuffers::Offset<ArgTypeAndIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgTypeAndIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgTypeAndIndex> CreateArgTypeAndIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::fbs::ArgType arg_type = onnxruntime::fbs::ArgType::INPUT,
    uint32_t index = 0) {
  ArgTypeAndIndexBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_arg_type(arg_type);
  return builder_.Finish();
}

struct KernelTypeStrArgsEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KernelTypeStrArgsEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_TYPE_STR = 4,
    VT_ARGS = 6
  };
  const flatbuffers::String *kernel_type_str() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_TYPE_STR);
  }
  bool KeyCompareLessThan(const KernelTypeStrArgsEntry *o) const {
    return *kernel_type_str() < *o->kernel_type_str();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(kernel_type_str()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KERNEL_TYPE_STR) &&
           verifier.VerifyString(kernel_type_str()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
};

struct KernelTypeStrArgsEntryBuilder {
  typedef KernelTypeStrArgsEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_type_str(flatbuffers::Offset<flatbuffers::String> kernel_type_str) {
    fbb_.AddOffset(KernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR, kernel_type_str);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>> args) {
    fbb_.AddOffset(KernelTypeStrArgsEntry::VT_ARGS, args);
  }
  explicit KernelTypeStrArgsEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KernelTypeStrArgsEntryBuilder &operator=(const KernelTypeStrArgsEntryBuilder &);
  flatbuffers::Offset<KernelTypeStrArgsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KernelTypeStrArgsEntry>(end);
    fbb_.Required(o, KernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR);
    return o;
  }
};

inline flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_type_str = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>> args = 0) {
  KernelTypeStrArgsEntryBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_kernel_type_str(kernel_type_str);
  return builder_.Finish();
}

inline flatbuffers::Offset<KernelTypeStrArgsEntry> CreateKernelTypeStrArgsEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_type_str = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>> *args = nullptr) {
  auto kernel_type_str__ = kernel_type_str ? _fbb.CreateString(kernel_type_str) : 0;
  auto args__ = args ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::fbs::ArgTypeAndIndex>>(*args) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrArgsEntry(
      _fbb,
      kernel_type_str__,
      args__);
}

struct OpIdKernelTypeStrArgsEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpIdKernelTypeStrArgsEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_ID = 4,
    VT_KERNEL_TYPE_STR_ARGS = 6
  };
  const flatbuffers::String *op_id() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_ID);
  }
  bool KeyCompareLessThan(const OpIdKernelTypeStrArgsEntry *o) const {
    return *op_id() < *o->op_id();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(op_id()->c_str(), val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *kernel_type_str_args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *>(VT_KERNEL_TYPE_STR_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OP_ID) &&
           verifier.VerifyString(op_id()) &&
           VerifyOffset(verifier, VT_KERNEL_TYPE_STR_ARGS) &&
           verifier.VerifyVector(kernel_type_str_args()) &&
           verifier.VerifyVectorOfTables(kernel_type_str_args()) &&
           verifier.EndTable();
  }
};

struct OpIdKernelTypeStrArgsEntryBuilder {
  typedef OpIdKernelTypeStrArgsEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_id(flatbuffers::Offset<flatbuffers::String> op_id) {
    fbb_.AddOffset(OpIdKernelTypeStrArgsEntry::VT_OP_ID, op_id);
  }
  void add_kernel_type_str_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>>> kernel_type_str_args) {
    fbb_.AddOffset(OpIdKernelTypeStrArgsEntry::VT_KERNEL_TYPE_STR_ARGS, kernel_type_str_args);
  }
  explicit OpIdKernelTypeStrArgsEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OpIdKernelTypeStrArgsEntryBuilder &operator=(const OpIdKernelTypeStrArgsEntryBuilder &);
  flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpIdKernelTypeStrArgsEntry>(end);
    fbb_.Required(o, OpIdKernelTypeStrArgsEntry::VT_OP_ID);
    return o;
  }
};

inline flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> op_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>>> kernel_type_str_args = 0) {
  OpIdKernelTypeStrArgsEntryBuilder builder_(_fbb);
  builder_.add_kernel_type_str_args(kernel_type_str_args);
  builder_.add_op_id(op_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpIdKernelTypeStrArgsEntry> CreateOpIdKernelTypeStrArgsEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *op_id = nullptr,
    std::vector<flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrArgsEntry>> *kernel_type_str_args = nullptr) {
  auto op_id__ = op_id ? _fbb.CreateString(op_id) : 0;
  auto kernel_type_str_args__ = kernel_type_str_args ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::KernelTypeStrArgsEntry>(kernel_type_str_args) : 0;
  return onnxruntime::fbs::CreateOpIdKernelTypeStrArgsEntry(
      _fbb,
      op_id__,
      kernel_type_str_args__);
}

struct KernelTypeStrResolver FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KernelTypeStrResolverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_KERNEL_TYPE_STR_ARGS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *op_kernel_type_str_args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *>(VT_OP_KERNEL_TYPE_STR_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP_KERNEL_TYPE_STR_ARGS) &&
           verifier.VerifyVector(op_kernel_type_str_args()) &&
           verifier.VerifyVectorOfTables(op_kernel_type_str_args()) &&
           verifier.EndTable();
  }
};

struct KernelTypeStrResolverBuilder {
  typedef KernelTypeStrResolver Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_op_kernel_type_str_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>>> op_kernel_type_str_args) {
    fbb_.AddOffset(KernelTypeStrResolver::VT_OP_KERNEL_TYPE_STR_ARGS, op_kernel_type_str_args);
  }
  explicit KernelTypeStrResolverBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KernelTypeStrResolverBuilder &operator=(const KernelTypeStrResolverBuilder &);
  flatbuffers::Offset<KernelTypeStrResolver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KernelTypeStrResolver>(end);
    return o;
  }
};

inline flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolver(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>>> op_kernel_type_str_args = 0) {
  KernelTypeStrResolverBuilder builder_(_fbb);
  builder_.add_op_kernel_type_str_args(op_kernel_type_str_args);
  return builder_.Finish();
}

inline flatbuffers::Offset<KernelTypeStrResolver> CreateKernelTypeStrResolverDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>> *op_kernel_type_str_args = nullptr) {
  auto op_kernel_type_str_args__ = op_kernel_type_str_args ? _fbb.CreateVectorOfSortedTables<onnxruntime::fbs::OpIdKernelTypeStrArgsEntry>(op_kernel_type_str_args) : 0;
  return onnxruntime::fbs::CreateKernelTypeStrResolver(
      _fbb,
      op_kernel_type_str_args__);
}

struct InferenceSession FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InferenceSessionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORT_VERSION = 4,
    VT_MODEL = 6,
    VT_KERNEL_TYPE_STR_RESOLVER = 10
  };
  const flatbuffers::String *ort_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ORT_VERSION);
  }
  const onnxruntime::fbs::Model *model() const {
    return GetPointer<const onnxruntime::fbs::Model *>(VT_MODEL);
  }
  const onnxruntime::fbs::KernelTypeStrResolver *kernel_type_str_resolver() const {
    return GetPointer<const onnxruntime::fbs::KernelTypeStrResolver *>(VT_KERNEL_TYPE_STR_RESOLVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORT_VERSION) &&
           verifier.VerifyString(ort_version()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyTable(model()) &&
           VerifyOffset(verifier, VT_KERNEL_TYPE_STR_RESOLVER) &&
           verifier.VerifyTable(kernel_type_str_resolver()) &&
           verifier.EndTable();
  }
};

struct InferenceSessionBuilder {
  typedef InferenceSession Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ort_version(flatbuffers::Offset<flatbuffers::String> ort_version) {
    fbb_.AddOffset(InferenceSession::VT_ORT_VERSION, ort_version);
  }
  void add_model(flatbuffers::Offset<onnxruntime::fbs::Model> model) {
    fbb_.AddOffset(InferenceSession::VT_MODEL, model);
  }
  void add_kernel_type_str_resolver(flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver) {
    fbb_.AddOffset(InferenceSession::VT_KERNEL_TYPE_STR_RESOLVER, kernel_type_str_resolver);
  }
  explicit InferenceSessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferenceSessionBuilder &operator=(const InferenceSessionBuilder &);
  flatbuffers::Offset<InferenceSession> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferenceSession>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferenceSession> CreateInferenceSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ort_version = 0,
    flatbuffers::Offset<onnxruntime::fbs::Model> model = 0,
    flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver = 0) {
  InferenceSessionBuilder builder_(_fbb);
  builder_.add_kernel_type_str_resolver(kernel_type_str_resolver);
  builder_.add_model(model);
  builder_.add_ort_version(ort_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferenceSession> CreateInferenceSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ort_version = nullptr,
    flatbuffers::Offset<onnxruntime::fbs::Model> model = 0,
    flatbuffers::Offset<onnxruntime::fbs::KernelTypeStrResolver> kernel_type_str_resolver = 0) {
  auto ort_version__ = ort_version ? _fbb.CreateString(ort_version) : 0;
  return onnxruntime::fbs::CreateInferenceSession(
      _fbb,
      ort_version__,
      model,
      kernel_type_str_resolver);
}

inline bool VerifyTypeInfoValue(flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type) {
  switch (type) {
    case TypeInfoValue::NONE: {
      return true;
    }
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::TensorTypeAndShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::SequenceType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<const onnxruntime::fbs::MapType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeInfoValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTypeInfoValue(
        verifier,  values->Get(i), types->GetEnum<TypeInfoValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const onnxruntime::fbs::InferenceSession *GetInferenceSession(const void *buf) {
  return flatbuffers::GetRoot<onnxruntime::fbs::InferenceSession>(buf);
}

inline const onnxruntime::fbs::InferenceSession *GetSizePrefixedInferenceSession(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<onnxruntime::fbs::InferenceSession>(buf);
}

inline const char *InferenceSessionIdentifier() {
  return "ORTM";
}

inline bool InferenceSessionBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, InferenceSessionIdentifier());
}

inline bool VerifyInferenceSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<onnxruntime::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline bool VerifySizePrefixedInferenceSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<onnxruntime::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline void FinishInferenceSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<onnxruntime::fbs::InferenceSession> root) {
  fbb.Finish(root, InferenceSessionIdentifier());
}

inline void FinishSizePrefixedInferenceSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<onnxruntime::fbs::InferenceSession> root) {
  fbb.FinishSizePrefixed(root, InferenceSessionIdentifier());
}

}  // namespace fbs
}  // namespace onnxruntime

#endif  // FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_FBS_H_
