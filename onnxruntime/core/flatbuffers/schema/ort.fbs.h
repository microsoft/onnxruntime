// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_EXPERIMENTAL_FBS_H_
#define FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_EXPERIMENTAL_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace onnxruntime {
namespace experimental {
namespace fbs {

struct Shape;
struct ShapeBuilder;

struct Dimension;
struct DimensionBuilder;

struct DimensionValue;
struct DimensionValueBuilder;

struct TensorTypeAndShape;
struct TensorTypeAndShapeBuilder;

struct MapType;
struct MapTypeBuilder;

struct SequenceType;
struct SequenceTypeBuilder;

struct EdgeEnd;

struct NodeEdge;
struct NodeEdgeBuilder;

struct Node;
struct NodeBuilder;

struct ValueInfo;
struct ValueInfoBuilder;

struct TypeInfo;
struct TypeInfoBuilder;

struct OperatorSetId;
struct OperatorSetIdBuilder;

struct Tensor;
struct TensorBuilder;

struct SparseTensor;
struct SparseTensorBuilder;

struct Attribute;
struct AttributeBuilder;

struct Graph;
struct GraphBuilder;

struct StringStringEntry;
struct StringStringEntryBuilder;

struct Model;
struct ModelBuilder;

struct KernelCreateInfos;
struct KernelCreateInfosBuilder;

struct SubGraphSessionState;
struct SubGraphSessionStateBuilder;

struct SessionState;
struct SessionStateBuilder;

struct InferenceSession;
struct InferenceSessionBuilder;

enum class AttributeType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  INT = 2,
  STRING = 3,
  TENSOR = 4,
  GRAPH = 5,
  FLOATS = 6,
  INTS = 7,
  STRINGS = 8,
  TENSORS = 9,
  GRAPHS = 10,
  SPARSE_TENSOR = 11,
  SPARSE_TENSORS = 12,
  MIN = UNDEFINED,
  MAX = SPARSE_TENSORS
};

inline const AttributeType (&EnumValuesAttributeType())[13] {
  static const AttributeType values[] = {
    AttributeType::UNDEFINED,
    AttributeType::FLOAT,
    AttributeType::INT,
    AttributeType::STRING,
    AttributeType::TENSOR,
    AttributeType::GRAPH,
    AttributeType::FLOATS,
    AttributeType::INTS,
    AttributeType::STRINGS,
    AttributeType::TENSORS,
    AttributeType::GRAPHS,
    AttributeType::SPARSE_TENSOR,
    AttributeType::SPARSE_TENSORS
  };
  return values;
}

inline const char * const *EnumNamesAttributeType() {
  static const char * const names[14] = {
    "UNDEFINED",
    "FLOAT",
    "INT",
    "STRING",
    "TENSOR",
    "GRAPH",
    "FLOATS",
    "INTS",
    "STRINGS",
    "TENSORS",
    "GRAPHS",
    "SPARSE_TENSOR",
    "SPARSE_TENSORS",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeType(AttributeType e) {
  if (flatbuffers::IsOutRange(e, AttributeType::UNDEFINED, AttributeType::SPARSE_TENSORS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeType()[index];
}

enum class DimensionValueType : int8_t {
  UNKNOWN = 0,
  VALUE = 1,
  PARAM = 2,
  MIN = UNKNOWN,
  MAX = PARAM
};

inline const DimensionValueType (&EnumValuesDimensionValueType())[3] {
  static const DimensionValueType values[] = {
    DimensionValueType::UNKNOWN,
    DimensionValueType::VALUE,
    DimensionValueType::PARAM
  };
  return values;
}

inline const char * const *EnumNamesDimensionValueType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "VALUE",
    "PARAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionValueType(DimensionValueType e) {
  if (flatbuffers::IsOutRange(e, DimensionValueType::UNKNOWN, DimensionValueType::PARAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionValueType()[index];
}

enum class TensorDataType : int32_t {
  UNDEFINED = 0,
  FLOAT = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  INT32 = 6,
  INT64 = 7,
  STRING = 8,
  BOOL = 9,
  FLOAT16 = 10,
  DOUBLE = 11,
  UINT32 = 12,
  UINT64 = 13,
  COMPLEX64 = 14,
  COMPLEX128 = 15,
  BFLOAT16 = 16,
  MIN = UNDEFINED,
  MAX = BFLOAT16
};

inline const TensorDataType (&EnumValuesTensorDataType())[17] {
  static const TensorDataType values[] = {
    TensorDataType::UNDEFINED,
    TensorDataType::FLOAT,
    TensorDataType::UINT8,
    TensorDataType::INT8,
    TensorDataType::UINT16,
    TensorDataType::INT16,
    TensorDataType::INT32,
    TensorDataType::INT64,
    TensorDataType::STRING,
    TensorDataType::BOOL,
    TensorDataType::FLOAT16,
    TensorDataType::DOUBLE,
    TensorDataType::UINT32,
    TensorDataType::UINT64,
    TensorDataType::COMPLEX64,
    TensorDataType::COMPLEX128,
    TensorDataType::BFLOAT16
  };
  return values;
}

inline const char * const *EnumNamesTensorDataType() {
  static const char * const names[18] = {
    "UNDEFINED",
    "FLOAT",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "INT32",
    "INT64",
    "STRING",
    "BOOL",
    "FLOAT16",
    "DOUBLE",
    "UINT32",
    "UINT64",
    "COMPLEX64",
    "COMPLEX128",
    "BFLOAT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorDataType(TensorDataType e) {
  if (flatbuffers::IsOutRange(e, TensorDataType::UNDEFINED, TensorDataType::BFLOAT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorDataType()[index];
}

enum class NodeType : int32_t {
  Primitive = 0,
  Fused = 1,
  MIN = Primitive,
  MAX = Fused
};

inline const NodeType (&EnumValuesNodeType())[2] {
  static const NodeType values[] = {
    NodeType::Primitive,
    NodeType::Fused
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[3] = {
    "Primitive",
    "Fused",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (flatbuffers::IsOutRange(e, NodeType::Primitive, NodeType::Fused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum class TypeInfoValue : uint8_t {
  NONE = 0,
  tensor_type = 1,
  sequence_type = 2,
  map_type = 3,
  MIN = NONE,
  MAX = map_type
};

inline const TypeInfoValue (&EnumValuesTypeInfoValue())[4] {
  static const TypeInfoValue values[] = {
    TypeInfoValue::NONE,
    TypeInfoValue::tensor_type,
    TypeInfoValue::sequence_type,
    TypeInfoValue::map_type
  };
  return values;
}

inline const char * const *EnumNamesTypeInfoValue() {
  static const char * const names[5] = {
    "NONE",
    "tensor_type",
    "sequence_type",
    "map_type",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeInfoValue(TypeInfoValue e) {
  if (flatbuffers::IsOutRange(e, TypeInfoValue::NONE, TypeInfoValue::map_type)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeInfoValue()[index];
}

template<typename T> struct TypeInfoValueTraits {
  static const TypeInfoValue enum_value = TypeInfoValue::NONE;
};

template<> struct TypeInfoValueTraits<onnxruntime::experimental::fbs::TensorTypeAndShape> {
  static const TypeInfoValue enum_value = TypeInfoValue::tensor_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::experimental::fbs::SequenceType> {
  static const TypeInfoValue enum_value = TypeInfoValue::sequence_type;
};

template<> struct TypeInfoValueTraits<onnxruntime::experimental::fbs::MapType> {
  static const TypeInfoValue enum_value = TypeInfoValue::map_type;
};

bool VerifyTypeInfoValue(flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type);
bool VerifyTypeInfoValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EdgeEnd FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t node_index_;
  int32_t src_arg_index_;
  int32_t dst_arg_index_;

 public:
  EdgeEnd() {
    memset(static_cast<void *>(this), 0, sizeof(EdgeEnd));
  }
  EdgeEnd(uint32_t _node_index, int32_t _src_arg_index, int32_t _dst_arg_index)
      : node_index_(flatbuffers::EndianScalar(_node_index)),
        src_arg_index_(flatbuffers::EndianScalar(_src_arg_index)),
        dst_arg_index_(flatbuffers::EndianScalar(_dst_arg_index)) {
  }
  uint32_t node_index() const {
    return flatbuffers::EndianScalar(node_index_);
  }
  int32_t src_arg_index() const {
    return flatbuffers::EndianScalar(src_arg_index_);
  }
  int32_t dst_arg_index() const {
    return flatbuffers::EndianScalar(dst_arg_index_);
  }
};
FLATBUFFERS_STRUCT_END(EdgeEnd, 12);

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>> *dim() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>> *>(VT_DIM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           verifier.VerifyVectorOfTables(dim()) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>>> dim) {
    fbb_.AddOffset(Shape::VT_DIM, dim);
  }
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>>> dim = 0) {
  ShapeBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shape> CreateShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>> *dim = nullptr) {
  auto dim__ = dim ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Dimension>>(*dim) : 0;
  return onnxruntime::experimental::fbs::CreateShape(
      _fbb,
      dim__);
}

struct Dimension FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DENOTATION = 6
  };
  const onnxruntime::experimental::fbs::DimensionValue *value() const {
    return GetPointer<const onnxruntime::experimental::fbs::DimensionValue *>(VT_VALUE);
  }
  const flatbuffers::String *denotation() const {
    return GetPointer<const flatbuffers::String *>(VT_DENOTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           verifier.EndTable();
  }
};

struct DimensionBuilder {
  typedef Dimension Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<onnxruntime::experimental::fbs::DimensionValue> value) {
    fbb_.AddOffset(Dimension::VT_VALUE, value);
  }
  void add_denotation(flatbuffers::Offset<flatbuffers::String> denotation) {
    fbb_.AddOffset(Dimension::VT_DENOTATION, denotation);
  }
  explicit DimensionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionBuilder &operator=(const DimensionBuilder &);
  flatbuffers::Offset<Dimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dimension>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dimension> CreateDimension(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::DimensionValue> value = 0,
    flatbuffers::Offset<flatbuffers::String> denotation = 0) {
  DimensionBuilder builder_(_fbb);
  builder_.add_denotation(denotation);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dimension> CreateDimensionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::DimensionValue> value = 0,
    const char *denotation = nullptr) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::experimental::fbs::CreateDimension(
      _fbb,
      value,
      denotation__);
}

struct DimensionValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimensionValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM_TYPE = 4,
    VT_DIM_VALUE = 6,
    VT_DIM_PARAM = 8
  };
  onnxruntime::experimental::fbs::DimensionValueType dim_type() const {
    return static_cast<onnxruntime::experimental::fbs::DimensionValueType>(GetField<int8_t>(VT_DIM_TYPE, 0));
  }
  int64_t dim_value() const {
    return GetField<int64_t>(VT_DIM_VALUE, 0);
  }
  const flatbuffers::String *dim_param() const {
    return GetPointer<const flatbuffers::String *>(VT_DIM_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DIM_TYPE) &&
           VerifyField<int64_t>(verifier, VT_DIM_VALUE) &&
           VerifyOffset(verifier, VT_DIM_PARAM) &&
           verifier.VerifyString(dim_param()) &&
           verifier.EndTable();
  }
};

struct DimensionValueBuilder {
  typedef DimensionValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim_type(onnxruntime::experimental::fbs::DimensionValueType dim_type) {
    fbb_.AddElement<int8_t>(DimensionValue::VT_DIM_TYPE, static_cast<int8_t>(dim_type), 0);
  }
  void add_dim_value(int64_t dim_value) {
    fbb_.AddElement<int64_t>(DimensionValue::VT_DIM_VALUE, dim_value, 0);
  }
  void add_dim_param(flatbuffers::Offset<flatbuffers::String> dim_param) {
    fbb_.AddOffset(DimensionValue::VT_DIM_PARAM, dim_param);
  }
  explicit DimensionValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionValueBuilder &operator=(const DimensionValueBuilder &);
  flatbuffers::Offset<DimensionValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionValue> CreateDimensionValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::experimental::fbs::DimensionValueType dim_type = onnxruntime::experimental::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    flatbuffers::Offset<flatbuffers::String> dim_param = 0) {
  DimensionValueBuilder builder_(_fbb);
  builder_.add_dim_value(dim_value);
  builder_.add_dim_param(dim_param);
  builder_.add_dim_type(dim_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DimensionValue> CreateDimensionValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::experimental::fbs::DimensionValueType dim_type = onnxruntime::experimental::fbs::DimensionValueType::UNKNOWN,
    int64_t dim_value = 0,
    const char *dim_param = nullptr) {
  auto dim_param__ = dim_param ? _fbb.CreateString(dim_param) : 0;
  return onnxruntime::experimental::fbs::CreateDimensionValue(
      _fbb,
      dim_type,
      dim_value,
      dim_param__);
}

struct TensorTypeAndShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorTypeAndShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4,
    VT_SHAPE = 6
  };
  onnxruntime::experimental::fbs::TensorDataType elem_type() const {
    return static_cast<onnxruntime::experimental::fbs::TensorDataType>(GetField<int32_t>(VT_ELEM_TYPE, 0));
  }
  const onnxruntime::experimental::fbs::Shape *shape() const {
    return GetPointer<const onnxruntime::experimental::fbs::Shape *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEM_TYPE) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
};

struct TensorTypeAndShapeBuilder {
  typedef TensorTypeAndShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elem_type(onnxruntime::experimental::fbs::TensorDataType elem_type) {
    fbb_.AddElement<int32_t>(TensorTypeAndShape::VT_ELEM_TYPE, static_cast<int32_t>(elem_type), 0);
  }
  void add_shape(flatbuffers::Offset<onnxruntime::experimental::fbs::Shape> shape) {
    fbb_.AddOffset(TensorTypeAndShape::VT_SHAPE, shape);
  }
  explicit TensorTypeAndShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorTypeAndShapeBuilder &operator=(const TensorTypeAndShapeBuilder &);
  flatbuffers::Offset<TensorTypeAndShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorTypeAndShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorTypeAndShape> CreateTensorTypeAndShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::experimental::fbs::TensorDataType elem_type = onnxruntime::experimental::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Shape> shape = 0) {
  TensorTypeAndShapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct MapType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_TYPE = 4,
    VT_VALUE_TYPE = 6
  };
  onnxruntime::experimental::fbs::TensorDataType key_type() const {
    return static_cast<onnxruntime::experimental::fbs::TensorDataType>(GetField<int32_t>(VT_KEY_TYPE, 0));
  }
  const onnxruntime::experimental::fbs::TypeInfo *value_type() const {
    return GetPointer<const onnxruntime::experimental::fbs::TypeInfo *>(VT_VALUE_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_TYPE) &&
           VerifyOffset(verifier, VT_VALUE_TYPE) &&
           verifier.VerifyTable(value_type()) &&
           verifier.EndTable();
  }
};

struct MapTypeBuilder {
  typedef MapType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_type(onnxruntime::experimental::fbs::TensorDataType key_type) {
    fbb_.AddElement<int32_t>(MapType::VT_KEY_TYPE, static_cast<int32_t>(key_type), 0);
  }
  void add_value_type(flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> value_type) {
    fbb_.AddOffset(MapType::VT_VALUE_TYPE, value_type);
  }
  explicit MapTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapTypeBuilder &operator=(const MapTypeBuilder &);
  flatbuffers::Offset<MapType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapType>(end);
    return o;
  }
};

inline flatbuffers::Offset<MapType> CreateMapType(
    flatbuffers::FlatBufferBuilder &_fbb,
    onnxruntime::experimental::fbs::TensorDataType key_type = onnxruntime::experimental::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> value_type = 0) {
  MapTypeBuilder builder_(_fbb);
  builder_.add_value_type(value_type);
  builder_.add_key_type(key_type);
  return builder_.Finish();
}

struct SequenceType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SequenceTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEM_TYPE = 4
  };
  const onnxruntime::experimental::fbs::TypeInfo *elem_type() const {
    return GetPointer<const onnxruntime::experimental::fbs::TypeInfo *>(VT_ELEM_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEM_TYPE) &&
           verifier.VerifyTable(elem_type()) &&
           verifier.EndTable();
  }
};

struct SequenceTypeBuilder {
  typedef SequenceType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elem_type(flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> elem_type) {
    fbb_.AddOffset(SequenceType::VT_ELEM_TYPE, elem_type);
  }
  explicit SequenceTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceTypeBuilder &operator=(const SequenceTypeBuilder &);
  flatbuffers::Offset<SequenceType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceType>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceType> CreateSequenceType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> elem_type = 0) {
  SequenceTypeBuilder builder_(_fbb);
  builder_.add_elem_type(elem_type);
  return builder_.Finish();
}

struct NodeEdge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeEdgeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDEX = 4,
    VT_INPUT_EDGES = 6,
    VT_OUTPUT_EDGES = 8
  };
  uint32_t node_index() const {
    return GetField<uint32_t>(VT_NODE_INDEX, 0);
  }
  const flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *> *input_edges() const {
    return GetPointer<const flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *> *>(VT_INPUT_EDGES);
  }
  const flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *> *output_edges() const {
    return GetPointer<const flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *> *>(VT_OUTPUT_EDGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUT_EDGES) &&
           verifier.VerifyVector(input_edges()) &&
           VerifyOffset(verifier, VT_OUTPUT_EDGES) &&
           verifier.VerifyVector(output_edges()) &&
           verifier.EndTable();
  }
};

struct NodeEdgeBuilder {
  typedef NodeEdge Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_index(uint32_t node_index) {
    fbb_.AddElement<uint32_t>(NodeEdge::VT_NODE_INDEX, node_index, 0);
  }
  void add_input_edges(flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *>> input_edges) {
    fbb_.AddOffset(NodeEdge::VT_INPUT_EDGES, input_edges);
  }
  void add_output_edges(flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *>> output_edges) {
    fbb_.AddOffset(NodeEdge::VT_OUTPUT_EDGES, output_edges);
  }
  explicit NodeEdgeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeEdgeBuilder &operator=(const NodeEdgeBuilder &);
  flatbuffers::Offset<NodeEdge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeEdge>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeEdge> CreateNodeEdge(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *>> input_edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<const onnxruntime::experimental::fbs::EdgeEnd *>> output_edges = 0) {
  NodeEdgeBuilder builder_(_fbb);
  builder_.add_output_edges(output_edges);
  builder_.add_input_edges(input_edges);
  builder_.add_node_index(node_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeEdge> CreateNodeEdgeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t node_index = 0,
    const std::vector<onnxruntime::experimental::fbs::EdgeEnd> *input_edges = nullptr,
    const std::vector<onnxruntime::experimental::fbs::EdgeEnd> *output_edges = nullptr) {
  auto input_edges__ = input_edges ? _fbb.CreateVectorOfStructs<onnxruntime::experimental::fbs::EdgeEnd>(*input_edges) : 0;
  auto output_edges__ = output_edges ? _fbb.CreateVectorOfStructs<onnxruntime::experimental::fbs::EdgeEnd>(*output_edges) : 0;
  return onnxruntime::experimental::fbs::CreateNodeEdge(
      _fbb,
      node_index,
      input_edges__,
      output_edges__);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DOMAIN = 8,
    VT_SINCE_VERSION = 10,
    VT_INDEX = 12,
    VT_OP_TYPE = 14,
    VT_TYPE = 16,
    VT_EXECUTION_PROVIDER_TYPE = 18,
    VT_INPUTS = 20,
    VT_OUTPUTS = 22,
    VT_ATTRIBUTES = 24,
    VT_INPUT_ARG_COUNTS = 26,
    VT_IMPLICIT_INPUTS = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int32_t since_version() const {
    return GetField<int32_t>(VT_SINCE_VERSION, 0);
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *op_type() const {
    return GetPointer<const flatbuffers::String *>(VT_OP_TYPE);
  }
  onnxruntime::experimental::fbs::NodeType type() const {
    return static_cast<onnxruntime::experimental::fbs::NodeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *execution_provider_type() const {
    return GetPointer<const flatbuffers::String *>(VT_EXECUTION_PROVIDER_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<int32_t> *input_arg_counts() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_ARG_COUNTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *implicit_inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_IMPLICIT_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int32_t>(verifier, VT_SINCE_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_OP_TYPE) &&
           verifier.VerifyString(op_type()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_EXECUTION_PROVIDER_TYPE) &&
           verifier.VerifyString(execution_provider_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_INPUT_ARG_COUNTS) &&
           verifier.VerifyVector(input_arg_counts()) &&
           VerifyOffset(verifier, VT_IMPLICIT_INPUTS) &&
           verifier.VerifyVector(implicit_inputs()) &&
           verifier.VerifyVectorOfStrings(implicit_inputs()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Node::VT_DOC_STRING, doc_string);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Node::VT_DOMAIN, domain);
  }
  void add_since_version(int32_t since_version) {
    fbb_.AddElement<int32_t>(Node::VT_SINCE_VERSION, since_version, 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Node::VT_INDEX, index, 0);
  }
  void add_op_type(flatbuffers::Offset<flatbuffers::String> op_type) {
    fbb_.AddOffset(Node::VT_OP_TYPE, op_type);
  }
  void add_type(onnxruntime::experimental::fbs::NodeType type) {
    fbb_.AddElement<int32_t>(Node::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_execution_provider_type(flatbuffers::Offset<flatbuffers::String> execution_provider_type) {
    fbb_.AddOffset(Node::VT_EXECUTION_PROVIDER_TYPE, execution_provider_type);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Node::VT_OUTPUTS, outputs);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>>> attributes) {
    fbb_.AddOffset(Node::VT_ATTRIBUTES, attributes);
  }
  void add_input_arg_counts(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_arg_counts) {
    fbb_.AddOffset(Node::VT_INPUT_ARG_COUNTS, input_arg_counts);
  }
  void add_implicit_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicit_inputs) {
    fbb_.AddOffset(Node::VT_IMPLICIT_INPUTS, implicit_inputs);
  }
  explicit NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int32_t since_version = 0,
    uint32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> op_type = 0,
    onnxruntime::experimental::fbs::NodeType type = onnxruntime::experimental::fbs::NodeType::Primitive,
    flatbuffers::Offset<flatbuffers::String> execution_provider_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_arg_counts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> implicit_inputs = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_implicit_inputs(implicit_inputs);
  builder_.add_input_arg_counts(input_arg_counts);
  builder_.add_attributes(attributes);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_execution_provider_type(execution_provider_type);
  builder_.add_type(type);
  builder_.add_op_type(op_type);
  builder_.add_index(index);
  builder_.add_since_version(since_version);
  builder_.add_domain(domain);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const char *domain = nullptr,
    int32_t since_version = 0,
    uint32_t index = 0,
    const char *op_type = nullptr,
    onnxruntime::experimental::fbs::NodeType type = onnxruntime::experimental::fbs::NodeType::Primitive,
    const char *execution_provider_type = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>> *attributes = nullptr,
    const std::vector<int32_t> *input_arg_counts = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *implicit_inputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto op_type__ = op_type ? _fbb.CreateString(op_type) : 0;
  auto execution_provider_type__ = execution_provider_type ? _fbb.CreateString(execution_provider_type) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Attribute>>(*attributes) : 0;
  auto input_arg_counts__ = input_arg_counts ? _fbb.CreateVector<int32_t>(*input_arg_counts) : 0;
  auto implicit_inputs__ = implicit_inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*implicit_inputs) : 0;
  return onnxruntime::experimental::fbs::CreateNode(
      _fbb,
      name__,
      doc_string__,
      domain__,
      since_version,
      index,
      op_type__,
      type,
      execution_provider_type__,
      inputs__,
      outputs__,
      attributes__,
      input_arg_counts__,
      implicit_inputs__);
}

struct ValueInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValueInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::experimental::fbs::TypeInfo *type() const {
    return GetPointer<const onnxruntime::experimental::fbs::TypeInfo *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

struct ValueInfoBuilder {
  typedef ValueInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ValueInfo::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(ValueInfo::VT_DOC_STRING, doc_string);
  }
  void add_type(flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> type) {
    fbb_.AddOffset(ValueInfo::VT_TYPE, type);
  }
  explicit ValueInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValueInfoBuilder &operator=(const ValueInfoBuilder &);
  flatbuffers::Offset<ValueInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ValueInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ValueInfo> CreateValueInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> type = 0) {
  ValueInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ValueInfo> CreateValueInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    flatbuffers::Offset<onnxruntime::experimental::fbs::TypeInfo> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  return onnxruntime::experimental::fbs::CreateValueInfo(
      _fbb,
      name__,
      doc_string__,
      type);
}

struct TypeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DENOTATION = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *denotation() const {
    return GetPointer<const flatbuffers::String *>(VT_DENOTATION);
  }
  onnxruntime::experimental::fbs::TypeInfoValue value_type() const {
    return static_cast<onnxruntime::experimental::fbs::TypeInfoValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const onnxruntime::experimental::fbs::TensorTypeAndShape *value_as_tensor_type() const {
    return value_type() == onnxruntime::experimental::fbs::TypeInfoValue::tensor_type ? static_cast<const onnxruntime::experimental::fbs::TensorTypeAndShape *>(value()) : nullptr;
  }
  const onnxruntime::experimental::fbs::SequenceType *value_as_sequence_type() const {
    return value_type() == onnxruntime::experimental::fbs::TypeInfoValue::sequence_type ? static_cast<const onnxruntime::experimental::fbs::SequenceType *>(value()) : nullptr;
  }
  const onnxruntime::experimental::fbs::MapType *value_as_map_type() const {
    return value_type() == onnxruntime::experimental::fbs::TypeInfoValue::map_type ? static_cast<const onnxruntime::experimental::fbs::MapType *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DENOTATION) &&
           verifier.VerifyString(denotation()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyTypeInfoValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const onnxruntime::experimental::fbs::TensorTypeAndShape *TypeInfo::value_as<onnxruntime::experimental::fbs::TensorTypeAndShape>() const {
  return value_as_tensor_type();
}

template<> inline const onnxruntime::experimental::fbs::SequenceType *TypeInfo::value_as<onnxruntime::experimental::fbs::SequenceType>() const {
  return value_as_sequence_type();
}

template<> inline const onnxruntime::experimental::fbs::MapType *TypeInfo::value_as<onnxruntime::experimental::fbs::MapType>() const {
  return value_as_map_type();
}

struct TypeInfoBuilder {
  typedef TypeInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_denotation(flatbuffers::Offset<flatbuffers::String> denotation) {
    fbb_.AddOffset(TypeInfo::VT_DENOTATION, denotation);
  }
  void add_value_type(onnxruntime::experimental::fbs::TypeInfoValue value_type) {
    fbb_.AddElement<uint8_t>(TypeInfo::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TypeInfo::VT_VALUE, value);
  }
  explicit TypeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TypeInfoBuilder &operator=(const TypeInfoBuilder &);
  flatbuffers::Offset<TypeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeInfo> CreateTypeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> denotation = 0,
    onnxruntime::experimental::fbs::TypeInfoValue value_type = onnxruntime::experimental::fbs::TypeInfoValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  TypeInfoBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_denotation(denotation);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeInfo> CreateTypeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *denotation = nullptr,
    onnxruntime::experimental::fbs::TypeInfoValue value_type = onnxruntime::experimental::fbs::TypeInfoValue::NONE,
    flatbuffers::Offset<void> value = 0) {
  auto denotation__ = denotation ? _fbb.CreateString(denotation) : 0;
  return onnxruntime::experimental::fbs::CreateTypeInfo(
      _fbb,
      denotation__,
      value_type,
      value);
}

struct OperatorSetId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorSetIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOMAIN = 4,
    VT_VERSION = 6
  };
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t version() const {
    return GetField<int64_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct OperatorSetIdBuilder {
  typedef OperatorSetId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(OperatorSetId::VT_DOMAIN, domain);
  }
  void add_version(int64_t version) {
    fbb_.AddElement<int64_t>(OperatorSetId::VT_VERSION, version, 0);
  }
  explicit OperatorSetIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorSetIdBuilder &operator=(const OperatorSetIdBuilder &);
  flatbuffers::Offset<OperatorSetId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorSetId>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorSetId> CreateOperatorSetId(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int64_t version = 0) {
  OperatorSetIdBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_domain(domain);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorSetId> CreateOperatorSetIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *domain = nullptr,
    int64_t version = 0) {
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  return onnxruntime::experimental::fbs::CreateOperatorSetId(
      _fbb,
      domain__,
      version);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_DIMS = 8,
    VT_DATA_TYPE = 10,
    VT_RAW_DATA = 12,
    VT_STRING_DATA = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  onnxruntime::experimental::fbs::TensorDataType data_type() const {
    return static_cast<onnxruntime::experimental::fbs::TensorDataType>(GetField<int32_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *raw_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *string_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRING_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_RAW_DATA) &&
           verifier.VerifyVector(raw_data()) &&
           VerifyOffset(verifier, VT_STRING_DATA) &&
           verifier.VerifyVector(string_data()) &&
           verifier.VerifyVectorOfStrings(string_data()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Tensor::VT_DOC_STRING, doc_string);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_data_type(onnxruntime::experimental::fbs::TensorDataType data_type) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATA_TYPE, static_cast<int32_t>(data_type), 0);
  }
  void add_raw_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data) {
    fbb_.AddOffset(Tensor::VT_RAW_DATA, raw_data);
  }
  void add_string_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_data) {
    fbb_.AddOffset(Tensor::VT_STRING_DATA, string_data);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0,
    onnxruntime::experimental::fbs::TensorDataType data_type = onnxruntime::experimental::fbs::TensorDataType::UNDEFINED,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_data = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_string_data(string_data);
  builder_.add_raw_data(raw_data);
  builder_.add_data_type(data_type);
  builder_.add_dims(dims);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    const std::vector<int64_t> *dims = nullptr,
    onnxruntime::experimental::fbs::TensorDataType data_type = onnxruntime::experimental::fbs::TensorDataType::UNDEFINED,
    const std::vector<uint8_t> *raw_data = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *string_data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  auto raw_data__ = raw_data ? _fbb.CreateVector<uint8_t>(*raw_data) : 0;
  auto string_data__ = string_data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*string_data) : 0;
  return onnxruntime::experimental::fbs::CreateTensor(
      _fbb,
      name__,
      doc_string__,
      dims__,
      data_type,
      raw_data__,
      string_data__);
}

struct SparseTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4,
    VT_INDICES = 6,
    VT_DIMS = 8
  };
  const onnxruntime::experimental::fbs::Tensor *values() const {
    return GetPointer<const onnxruntime::experimental::fbs::Tensor *>(VT_VALUES);
  }
  const onnxruntime::experimental::fbs::Tensor *indices() const {
    return GetPointer<const onnxruntime::experimental::fbs::Tensor *>(VT_INDICES);
  }
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyTable(values()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyTable(indices()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct SparseTensorBuilder {
  typedef SparseTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> values) {
    fbb_.AddOffset(SparseTensor::VT_VALUES, values);
  }
  void add_indices(flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> indices) {
    fbb_.AddOffset(SparseTensor::VT_INDICES, indices);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(SparseTensor::VT_DIMS, dims);
  }
  explicit SparseTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseTensorBuilder &operator=(const SparseTensorBuilder &);
  flatbuffers::Offset<SparseTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseTensor> CreateSparseTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> values = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  SparseTensorBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_indices(indices);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparseTensor> CreateSparseTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> values = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> indices = 0,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return onnxruntime::experimental::fbs::CreateSparseTensor(
      _fbb,
      values,
      indices,
      dims__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DOC_STRING = 6,
    VT_TYPE = 8,
    VT_F = 10,
    VT_I = 12,
    VT_S = 14,
    VT_T = 16,
    VT_G = 18,
    VT_FLOATS = 20,
    VT_INTS = 22,
    VT_STRINGS = 24,
    VT_TENSORS = 26,
    VT_GRAPHS = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  onnxruntime::experimental::fbs::AttributeType type() const {
    return static_cast<onnxruntime::experimental::fbs::AttributeType>(GetField<int32_t>(VT_TYPE, 0));
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  int64_t i() const {
    return GetField<int64_t>(VT_I, 0);
  }
  const flatbuffers::String *s() const {
    return GetPointer<const flatbuffers::String *>(VT_S);
  }
  const onnxruntime::experimental::fbs::Tensor *t() const {
    return GetPointer<const onnxruntime::experimental::fbs::Tensor *>(VT_T);
  }
  const onnxruntime::experimental::fbs::Graph *g() const {
    return GetPointer<const onnxruntime::experimental::fbs::Graph *>(VT_G);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<int64_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *strings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>> *graphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>> *>(VT_GRAPHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_F) &&
           VerifyField<int64_t>(verifier, VT_I) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyOffset(verifier, VT_T) &&
           verifier.VerifyTable(t()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyTable(g()) &&
           VerifyOffset(verifier, VT_FLOATS) &&
           verifier.VerifyVector(floats()) &&
           VerifyOffset(verifier, VT_INTS) &&
           verifier.VerifyVector(ints()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Attribute::VT_DOC_STRING, doc_string);
  }
  void add_type(onnxruntime::experimental::fbs::AttributeType type) {
    fbb_.AddElement<int32_t>(Attribute::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attribute::VT_F, f, 0.0f);
  }
  void add_i(int64_t i) {
    fbb_.AddElement<int64_t>(Attribute::VT_I, i, 0);
  }
  void add_s(flatbuffers::Offset<flatbuffers::String> s) {
    fbb_.AddOffset(Attribute::VT_S, s);
  }
  void add_t(flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> t) {
    fbb_.AddOffset(Attribute::VT_T, t);
  }
  void add_g(flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> g) {
    fbb_.AddOffset(Attribute::VT_G, g);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Attribute::VT_FLOATS, floats);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ints) {
    fbb_.AddOffset(Attribute::VT_INTS, ints);
  }
  void add_strings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings) {
    fbb_.AddOffset(Attribute::VT_STRINGS, strings);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>> tensors) {
    fbb_.AddOffset(Attribute::VT_TENSORS, tensors);
  }
  void add_graphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>>> graphs) {
    fbb_.AddOffset(Attribute::VT_GRAPHS, graphs);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeBuilder &operator=(const AttributeBuilder &);
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    onnxruntime::experimental::fbs::AttributeType type = onnxruntime::experimental::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    flatbuffers::Offset<flatbuffers::String> s = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> t = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> g = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> strings = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>>> graphs = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_i(i);
  builder_.add_graphs(graphs);
  builder_.add_tensors(tensors);
  builder_.add_strings(strings);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_g(g);
  builder_.add_t(t);
  builder_.add_s(s);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_doc_string(doc_string);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *doc_string = nullptr,
    onnxruntime::experimental::fbs::AttributeType type = onnxruntime::experimental::fbs::AttributeType::UNDEFINED,
    float f = 0.0f,
    int64_t i = 0,
    const char *s = nullptr,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor> t = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> g = 0,
    const std::vector<float> *floats = nullptr,
    const std::vector<int64_t> *ints = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *strings = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *tensors = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>> *graphs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto floats__ = floats ? _fbb.CreateVector<float>(*floats) : 0;
  auto ints__ = ints ? _fbb.CreateVector<int64_t>(*ints) : 0;
  auto strings__ = strings ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*strings) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>(*tensors) : 0;
  auto graphs__ = graphs ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Graph>>(*graphs) : 0;
  return onnxruntime::experimental::fbs::CreateAttribute(
      _fbb,
      name__,
      doc_string__,
      type,
      f,
      i,
      s__,
      t,
      g,
      floats__,
      ints__,
      strings__,
      tensors__,
      graphs__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INITIALIZERS = 4,
    VT_NODE_ARGS = 6,
    VT_NODES = 8,
    VT_MAX_NODE_INDEX = 10,
    VT_NODE_EDGES = 12,
    VT_INPUTS = 14,
    VT_OUTPUTS = 16,
    VT_SPARSE_INITIALIZERS = 18
  };
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>> *node_args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>> *>(VT_NODE_ARGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>> *>(VT_NODES);
  }
  uint32_t max_node_index() const {
    return GetField<uint32_t>(VT_MAX_NODE_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>> *node_edges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>> *>(VT_NODE_EDGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>> *sparse_initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>> *>(VT_SPARSE_INITIALIZERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_NODE_ARGS) &&
           verifier.VerifyVector(node_args()) &&
           verifier.VerifyVectorOfTables(node_args()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_NODE_INDEX) &&
           VerifyOffset(verifier, VT_NODE_EDGES) &&
           verifier.VerifyVector(node_edges()) &&
           verifier.VerifyVectorOfTables(node_edges()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           VerifyOffset(verifier, VT_SPARSE_INITIALIZERS) &&
           verifier.VerifyVector(sparse_initializers()) &&
           verifier.VerifyVectorOfTables(sparse_initializers()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>> initializers) {
    fbb_.AddOffset(Graph::VT_INITIALIZERS, initializers);
  }
  void add_node_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>>> node_args) {
    fbb_.AddOffset(Graph::VT_NODE_ARGS, node_args);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>>> nodes) {
    fbb_.AddOffset(Graph::VT_NODES, nodes);
  }
  void add_max_node_index(uint32_t max_node_index) {
    fbb_.AddElement<uint32_t>(Graph::VT_MAX_NODE_INDEX, max_node_index, 0);
  }
  void add_node_edges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>>> node_edges) {
    fbb_.AddOffset(Graph::VT_NODE_EDGES, node_edges);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Graph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Graph::VT_OUTPUTS, outputs);
  }
  void add_sparse_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>>> sparse_initializers) {
    fbb_.AddOffset(Graph::VT_SPARSE_INITIALIZERS, sparse_initializers);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GraphBuilder &operator=(const GraphBuilder &);
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>>> node_args = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>>> nodes = 0,
    uint32_t max_node_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>>> node_edges = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>>> sparse_initializers = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_sparse_initializers(sparse_initializers);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_node_edges(node_edges);
  builder_.add_max_node_index(max_node_index);
  builder_.add_nodes(nodes);
  builder_.add_node_args(node_args);
  builder_.add_initializers(initializers);
  return builder_.Finish();
}

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>> *node_args = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>> *nodes = nullptr,
    uint32_t max_node_index = 0,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>> *node_edges = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>> *sparse_initializers = nullptr) {
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Tensor>>(*initializers) : 0;
  auto node_args__ = node_args ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::ValueInfo>>(*node_args) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::Node>>(*nodes) : 0;
  auto node_edges__ = node_edges ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::NodeEdge>>(*node_edges) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  auto sparse_initializers__ = sparse_initializers ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::SparseTensor>>(*sparse_initializers) : 0;
  return onnxruntime::experimental::fbs::CreateGraph(
      _fbb,
      initializers__,
      node_args__,
      nodes__,
      max_node_index,
      node_edges__,
      inputs__,
      outputs__,
      sparse_initializers__);
}

struct StringStringEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringStringEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringStringEntryBuilder {
  typedef StringStringEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(StringStringEntry::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringStringEntry::VT_VALUE, value);
  }
  explicit StringStringEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringStringEntryBuilder &operator=(const StringStringEntryBuilder &);
  flatbuffers::Offset<StringStringEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringStringEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringStringEntry> CreateStringStringEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringStringEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringStringEntry> CreateStringStringEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return onnxruntime::experimental::fbs::CreateStringStringEntry(
      _fbb,
      key__,
      value__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IR_VERSION = 4,
    VT_OPSET_IMPORT = 6,
    VT_PRODUCER_NAME = 8,
    VT_PRODUCER_VERSION = 10,
    VT_DOMAIN = 12,
    VT_MODEL_VERSION = 14,
    VT_DOC_STRING = 16,
    VT_GRAPH = 18,
    VT_GRAPH_DOC_STRING = 20,
    VT_METADATA_PROPS = 22
  };
  int64_t ir_version() const {
    return GetField<int64_t>(VT_IR_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>> *opset_import() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>> *>(VT_OPSET_IMPORT);
  }
  const flatbuffers::String *producer_name() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCER_NAME);
  }
  const flatbuffers::String *producer_version() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCER_VERSION);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  int64_t model_version() const {
    return GetField<int64_t>(VT_MODEL_VERSION, 0);
  }
  const flatbuffers::String *doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_DOC_STRING);
  }
  const onnxruntime::experimental::fbs::Graph *graph() const {
    return GetPointer<const onnxruntime::experimental::fbs::Graph *>(VT_GRAPH);
  }
  const flatbuffers::String *graph_doc_string() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPH_DOC_STRING);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>> *metadata_props() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>> *>(VT_METADATA_PROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IR_VERSION) &&
           VerifyOffset(verifier, VT_OPSET_IMPORT) &&
           verifier.VerifyVector(opset_import()) &&
           verifier.VerifyVectorOfTables(opset_import()) &&
           VerifyOffset(verifier, VT_PRODUCER_NAME) &&
           verifier.VerifyString(producer_name()) &&
           VerifyOffset(verifier, VT_PRODUCER_VERSION) &&
           verifier.VerifyString(producer_version()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyField<int64_t>(verifier, VT_MODEL_VERSION) &&
           VerifyOffset(verifier, VT_DOC_STRING) &&
           verifier.VerifyString(doc_string()) &&
           VerifyOffset(verifier, VT_GRAPH) &&
           verifier.VerifyTable(graph()) &&
           VerifyOffset(verifier, VT_GRAPH_DOC_STRING) &&
           verifier.VerifyString(graph_doc_string()) &&
           VerifyOffset(verifier, VT_METADATA_PROPS) &&
           verifier.VerifyVector(metadata_props()) &&
           verifier.VerifyVectorOfTables(metadata_props()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ir_version(int64_t ir_version) {
    fbb_.AddElement<int64_t>(Model::VT_IR_VERSION, ir_version, 0);
  }
  void add_opset_import(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>>> opset_import) {
    fbb_.AddOffset(Model::VT_OPSET_IMPORT, opset_import);
  }
  void add_producer_name(flatbuffers::Offset<flatbuffers::String> producer_name) {
    fbb_.AddOffset(Model::VT_PRODUCER_NAME, producer_name);
  }
  void add_producer_version(flatbuffers::Offset<flatbuffers::String> producer_version) {
    fbb_.AddOffset(Model::VT_PRODUCER_VERSION, producer_version);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(Model::VT_DOMAIN, domain);
  }
  void add_model_version(int64_t model_version) {
    fbb_.AddElement<int64_t>(Model::VT_MODEL_VERSION, model_version, 0);
  }
  void add_doc_string(flatbuffers::Offset<flatbuffers::String> doc_string) {
    fbb_.AddOffset(Model::VT_DOC_STRING, doc_string);
  }
  void add_graph(flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> graph) {
    fbb_.AddOffset(Model::VT_GRAPH, graph);
  }
  void add_graph_doc_string(flatbuffers::Offset<flatbuffers::String> graph_doc_string) {
    fbb_.AddOffset(Model::VT_GRAPH_DOC_STRING, graph_doc_string);
  }
  void add_metadata_props(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>>> metadata_props) {
    fbb_.AddOffset(Model::VT_METADATA_PROPS, metadata_props);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>>> opset_import = 0,
    flatbuffers::Offset<flatbuffers::String> producer_name = 0,
    flatbuffers::Offset<flatbuffers::String> producer_version = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    int64_t model_version = 0,
    flatbuffers::Offset<flatbuffers::String> doc_string = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> graph = 0,
    flatbuffers::Offset<flatbuffers::String> graph_doc_string = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>>> metadata_props = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_model_version(model_version);
  builder_.add_ir_version(ir_version);
  builder_.add_metadata_props(metadata_props);
  builder_.add_graph_doc_string(graph_doc_string);
  builder_.add_graph(graph);
  builder_.add_doc_string(doc_string);
  builder_.add_domain(domain);
  builder_.add_producer_version(producer_version);
  builder_.add_producer_name(producer_name);
  builder_.add_opset_import(opset_import);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t ir_version = 0,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>> *opset_import = nullptr,
    const char *producer_name = nullptr,
    const char *producer_version = nullptr,
    const char *domain = nullptr,
    int64_t model_version = 0,
    const char *doc_string = nullptr,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Graph> graph = 0,
    const char *graph_doc_string = nullptr,
    const std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>> *metadata_props = nullptr) {
  auto opset_import__ = opset_import ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::OperatorSetId>>(*opset_import) : 0;
  auto producer_name__ = producer_name ? _fbb.CreateString(producer_name) : 0;
  auto producer_version__ = producer_version ? _fbb.CreateString(producer_version) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto doc_string__ = doc_string ? _fbb.CreateString(doc_string) : 0;
  auto graph_doc_string__ = graph_doc_string ? _fbb.CreateString(graph_doc_string) : 0;
  auto metadata_props__ = metadata_props ? _fbb.CreateVector<flatbuffers::Offset<onnxruntime::experimental::fbs::StringStringEntry>>(*metadata_props) : 0;
  return onnxruntime::experimental::fbs::CreateModel(
      _fbb,
      ir_version,
      opset_import__,
      producer_name__,
      producer_version__,
      domain__,
      model_version,
      doc_string__,
      graph,
      graph_doc_string__,
      metadata_props__);
}

struct KernelCreateInfos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KernelCreateInfosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INDICES = 4,
    VT_KERNEL_DEF_HASHES = 6
  };
  const flatbuffers::Vector<uint32_t> *node_indices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODE_INDICES);
  }
  const flatbuffers::Vector<uint64_t> *kernel_def_hashes() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_KERNEL_DEF_HASHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyOffset(verifier, VT_KERNEL_DEF_HASHES) &&
           verifier.VerifyVector(kernel_def_hashes()) &&
           verifier.EndTable();
  }
};

struct KernelCreateInfosBuilder {
  typedef KernelCreateInfos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node_indices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices) {
    fbb_.AddOffset(KernelCreateInfos::VT_NODE_INDICES, node_indices);
  }
  void add_kernel_def_hashes(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> kernel_def_hashes) {
    fbb_.AddOffset(KernelCreateInfos::VT_KERNEL_DEF_HASHES, kernel_def_hashes);
  }
  explicit KernelCreateInfosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KernelCreateInfosBuilder &operator=(const KernelCreateInfosBuilder &);
  flatbuffers::Offset<KernelCreateInfos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KernelCreateInfos>(end);
    return o;
  }
};

inline flatbuffers::Offset<KernelCreateInfos> CreateKernelCreateInfos(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> node_indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> kernel_def_hashes = 0) {
  KernelCreateInfosBuilder builder_(_fbb);
  builder_.add_kernel_def_hashes(kernel_def_hashes);
  builder_.add_node_indices(node_indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<KernelCreateInfos> CreateKernelCreateInfosDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *node_indices = nullptr,
    const std::vector<uint64_t> *kernel_def_hashes = nullptr) {
  auto node_indices__ = node_indices ? _fbb.CreateVector<uint32_t>(*node_indices) : 0;
  auto kernel_def_hashes__ = kernel_def_hashes ? _fbb.CreateVector<uint64_t>(*kernel_def_hashes) : 0;
  return onnxruntime::experimental::fbs::CreateKernelCreateInfos(
      _fbb,
      node_indices__,
      kernel_def_hashes__);
}

struct SubGraphSessionState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphSessionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_ID = 4,
    VT_SESSION_STATE = 6
  };
  const flatbuffers::String *graph_id() const {
    return GetPointer<const flatbuffers::String *>(VT_GRAPH_ID);
  }
  bool KeyCompareLessThan(const SubGraphSessionState *o) const {
    return *graph_id() < *o->graph_id();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(graph_id()->c_str(), val);
  }
  const onnxruntime::experimental::fbs::SessionState *session_state() const {
    return GetPointer<const onnxruntime::experimental::fbs::SessionState *>(VT_SESSION_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRAPH_ID) &&
           verifier.VerifyString(graph_id()) &&
           VerifyOffset(verifier, VT_SESSION_STATE) &&
           verifier.VerifyTable(session_state()) &&
           verifier.EndTable();
  }
};

struct SubGraphSessionStateBuilder {
  typedef SubGraphSessionState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graph_id(flatbuffers::Offset<flatbuffers::String> graph_id) {
    fbb_.AddOffset(SubGraphSessionState::VT_GRAPH_ID, graph_id);
  }
  void add_session_state(flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state) {
    fbb_.AddOffset(SubGraphSessionState::VT_SESSION_STATE, session_state);
  }
  explicit SubGraphSessionStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphSessionStateBuilder &operator=(const SubGraphSessionStateBuilder &);
  flatbuffers::Offset<SubGraphSessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraphSessionState>(end);
    fbb_.Required(o, SubGraphSessionState::VT_GRAPH_ID);
    return o;
  }
};

inline flatbuffers::Offset<SubGraphSessionState> CreateSubGraphSessionState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> graph_id = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state = 0) {
  SubGraphSessionStateBuilder builder_(_fbb);
  builder_.add_session_state(session_state);
  builder_.add_graph_id(graph_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraphSessionState> CreateSubGraphSessionStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *graph_id = nullptr,
    flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state = 0) {
  auto graph_id__ = graph_id ? _fbb.CreateString(graph_id) : 0;
  return onnxruntime::experimental::fbs::CreateSubGraphSessionState(
      _fbb,
      graph_id__,
      session_state);
}

struct SessionState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SessionStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNELS = 4,
    VT_SUB_GRAPH_SESSION_STATES = 6
  };
  const onnxruntime::experimental::fbs::KernelCreateInfos *kernels() const {
    return GetPointer<const onnxruntime::experimental::fbs::KernelCreateInfos *>(VT_KERNELS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SubGraphSessionState>> *sub_graph_session_states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SubGraphSessionState>> *>(VT_SUB_GRAPH_SESSION_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyTable(kernels()) &&
           VerifyOffset(verifier, VT_SUB_GRAPH_SESSION_STATES) &&
           verifier.VerifyVector(sub_graph_session_states()) &&
           verifier.VerifyVectorOfTables(sub_graph_session_states()) &&
           verifier.EndTable();
  }
};

struct SessionStateBuilder {
  typedef SessionState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernels(flatbuffers::Offset<onnxruntime::experimental::fbs::KernelCreateInfos> kernels) {
    fbb_.AddOffset(SessionState::VT_KERNELS, kernels);
  }
  void add_sub_graph_session_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SubGraphSessionState>>> sub_graph_session_states) {
    fbb_.AddOffset(SessionState::VT_SUB_GRAPH_SESSION_STATES, sub_graph_session_states);
  }
  explicit SessionStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionStateBuilder &operator=(const SessionStateBuilder &);
  flatbuffers::Offset<SessionState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SessionState>(end);
    return o;
  }
};

inline flatbuffers::Offset<SessionState> CreateSessionState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::KernelCreateInfos> kernels = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SubGraphSessionState>>> sub_graph_session_states = 0) {
  SessionStateBuilder builder_(_fbb);
  builder_.add_sub_graph_session_states(sub_graph_session_states);
  builder_.add_kernels(kernels);
  return builder_.Finish();
}

inline flatbuffers::Offset<SessionState> CreateSessionStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::KernelCreateInfos> kernels = 0,
    std::vector<flatbuffers::Offset<onnxruntime::experimental::fbs::SubGraphSessionState>> *sub_graph_session_states = nullptr) {
  auto sub_graph_session_states__ = sub_graph_session_states ? _fbb.CreateVectorOfSortedTables<onnxruntime::experimental::fbs::SubGraphSessionState>(sub_graph_session_states) : 0;
  return onnxruntime::experimental::fbs::CreateSessionState(
      _fbb,
      kernels,
      sub_graph_session_states__);
}

struct InferenceSession FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InferenceSessionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORT_VERSION = 4,
    VT_MODEL = 6,
    VT_SESSION_STATE = 8
  };
  const flatbuffers::String *ort_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ORT_VERSION);
  }
  const onnxruntime::experimental::fbs::Model *model() const {
    return GetPointer<const onnxruntime::experimental::fbs::Model *>(VT_MODEL);
  }
  const onnxruntime::experimental::fbs::SessionState *session_state() const {
    return GetPointer<const onnxruntime::experimental::fbs::SessionState *>(VT_SESSION_STATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORT_VERSION) &&
           verifier.VerifyString(ort_version()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyTable(model()) &&
           VerifyOffset(verifier, VT_SESSION_STATE) &&
           verifier.VerifyTable(session_state()) &&
           verifier.EndTable();
  }
};

struct InferenceSessionBuilder {
  typedef InferenceSession Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ort_version(flatbuffers::Offset<flatbuffers::String> ort_version) {
    fbb_.AddOffset(InferenceSession::VT_ORT_VERSION, ort_version);
  }
  void add_model(flatbuffers::Offset<onnxruntime::experimental::fbs::Model> model) {
    fbb_.AddOffset(InferenceSession::VT_MODEL, model);
  }
  void add_session_state(flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state) {
    fbb_.AddOffset(InferenceSession::VT_SESSION_STATE, session_state);
  }
  explicit InferenceSessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferenceSessionBuilder &operator=(const InferenceSessionBuilder &);
  flatbuffers::Offset<InferenceSession> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferenceSession>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferenceSession> CreateInferenceSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ort_version = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Model> model = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state = 0) {
  InferenceSessionBuilder builder_(_fbb);
  builder_.add_session_state(session_state);
  builder_.add_model(model);
  builder_.add_ort_version(ort_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferenceSession> CreateInferenceSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ort_version = nullptr,
    flatbuffers::Offset<onnxruntime::experimental::fbs::Model> model = 0,
    flatbuffers::Offset<onnxruntime::experimental::fbs::SessionState> session_state = 0) {
  auto ort_version__ = ort_version ? _fbb.CreateString(ort_version) : 0;
  return onnxruntime::experimental::fbs::CreateInferenceSession(
      _fbb,
      ort_version__,
      model,
      session_state);
}

inline bool VerifyTypeInfoValue(flatbuffers::Verifier &verifier, const void *obj, TypeInfoValue type) {
  switch (type) {
    case TypeInfoValue::NONE: {
      return true;
    }
    case TypeInfoValue::tensor_type: {
      auto ptr = reinterpret_cast<const onnxruntime::experimental::fbs::TensorTypeAndShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::sequence_type: {
      auto ptr = reinterpret_cast<const onnxruntime::experimental::fbs::SequenceType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TypeInfoValue::map_type: {
      auto ptr = reinterpret_cast<const onnxruntime::experimental::fbs::MapType *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeInfoValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTypeInfoValue(
        verifier,  values->Get(i), types->GetEnum<TypeInfoValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const onnxruntime::experimental::fbs::InferenceSession *GetInferenceSession(const void *buf) {
  return flatbuffers::GetRoot<onnxruntime::experimental::fbs::InferenceSession>(buf);
}

inline const onnxruntime::experimental::fbs::InferenceSession *GetSizePrefixedInferenceSession(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<onnxruntime::experimental::fbs::InferenceSession>(buf);
}

inline const char *InferenceSessionIdentifier() {
  return "ORTM";
}

inline bool InferenceSessionBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, InferenceSessionIdentifier());
}

inline bool VerifyInferenceSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<onnxruntime::experimental::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline bool VerifySizePrefixedInferenceSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<onnxruntime::experimental::fbs::InferenceSession>(InferenceSessionIdentifier());
}

inline void FinishInferenceSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::InferenceSession> root) {
  fbb.Finish(root, InferenceSessionIdentifier());
}

inline void FinishSizePrefixedInferenceSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<onnxruntime::experimental::fbs::InferenceSession> root) {
  fbb.FinishSizePrefixed(root, InferenceSessionIdentifier());
}

}  // namespace fbs
}  // namespace experimental
}  // namespace onnxruntime

#endif  // FLATBUFFERS_GENERATED_ORT_ONNXRUNTIME_EXPERIMENTAL_FBS_H_
