// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_
#define FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_

#include "flatbuffers/flatbuffers.h"

namespace dml {
namespace ir {
namespace operatorFieldTypes {

struct AttributeDesc;
struct AttributeDescBuilder;

struct Activation;
struct ActivationBuilder;

struct ActivationArray;
struct ActivationArrayBuilder;

struct UInt8;

struct UInt16;

struct UInt32;

struct UInt64;

struct Int8;

struct Int16;

struct Int32;

struct Int64;

struct Float32;

struct Float64;

struct UIntArray;
struct UIntArrayBuilder;

struct IntArray;
struct IntArrayBuilder;

struct FloatArray;
struct FloatArrayBuilder;

struct ScaleBias;

struct Size2D;

struct ByteArray;

struct ScalarUnionData;
struct ScalarUnionDataBuilder;

struct Bool;

enum AttributeFieldVariant {
  AttributeFieldVariant_NONE = 0,
  AttributeFieldVariant_Activation = 1,
  AttributeFieldVariant_ActivationArray = 2,
  AttributeFieldVariant_UInt32 = 3,
  AttributeFieldVariant_UInt64 = 4,
  AttributeFieldVariant_Int32 = 5,
  AttributeFieldVariant_Float32 = 6,
  AttributeFieldVariant_UIntArray = 7,
  AttributeFieldVariant_IntArray = 8,
  AttributeFieldVariant_FloatArray = 9,
  AttributeFieldVariant_ScaleBias = 10,
  AttributeFieldVariant_Size2D = 11,
  AttributeFieldVariant_ScalarUnionData = 12,
  AttributeFieldVariant_Bool = 13,
  AttributeFieldVariant_MIN = AttributeFieldVariant_NONE,
  AttributeFieldVariant_MAX = AttributeFieldVariant_Bool
};

inline const AttributeFieldVariant (&EnumValuesAttributeFieldVariant())[14] {
  static const AttributeFieldVariant values[] = {
    AttributeFieldVariant_NONE,
    AttributeFieldVariant_Activation,
    AttributeFieldVariant_ActivationArray,
    AttributeFieldVariant_UInt32,
    AttributeFieldVariant_UInt64,
    AttributeFieldVariant_Int32,
    AttributeFieldVariant_Float32,
    AttributeFieldVariant_UIntArray,
    AttributeFieldVariant_IntArray,
    AttributeFieldVariant_FloatArray,
    AttributeFieldVariant_ScaleBias,
    AttributeFieldVariant_Size2D,
    AttributeFieldVariant_ScalarUnionData,
    AttributeFieldVariant_Bool
  };
  return values;
}

inline const char * const *EnumNamesAttributeFieldVariant() {
  static const char * const names[15] = {
    "NONE",
    "Activation",
    "ActivationArray",
    "UInt32",
    "UInt64",
    "Int32",
    "Float32",
    "UIntArray",
    "IntArray",
    "FloatArray",
    "ScaleBias",
    "Size2D",
    "ScalarUnionData",
    "Bool",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeFieldVariant(AttributeFieldVariant e) {
  if (flatbuffers::IsOutRange(e, AttributeFieldVariant_NONE, AttributeFieldVariant_Bool)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeFieldVariant()[index];
}

template<typename T> struct AttributeFieldVariantTraits {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_NONE;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Activation> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Activation;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ActivationArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ActivationArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UInt32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UInt32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UInt64> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UInt64;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Int32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Int32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Float32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Float32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UIntArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UIntArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::IntArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_IntArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::FloatArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_FloatArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ScaleBias> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ScaleBias;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Size2D> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Size2D;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ScalarUnionData> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ScalarUnionData;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Bool> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Bool;
};

bool VerifyAttributeFieldVariant(flatbuffers::Verifier &verifier, const void *obj, AttributeFieldVariant type);
bool VerifyAttributeFieldVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ScalarVariant {
  ScalarVariant_NONE = 0,
  ScalarVariant_ByteArray = 1,
  ScalarVariant_Int8 = 2,
  ScalarVariant_UInt8 = 3,
  ScalarVariant_Int16 = 4,
  ScalarVariant_UInt16 = 5,
  ScalarVariant_Int32 = 6,
  ScalarVariant_UInt32 = 7,
  ScalarVariant_Int64 = 8,
  ScalarVariant_UInt64 = 9,
  ScalarVariant_Float32 = 10,
  ScalarVariant_Float64 = 11,
  ScalarVariant_MIN = ScalarVariant_NONE,
  ScalarVariant_MAX = ScalarVariant_Float64
};

inline const ScalarVariant (&EnumValuesScalarVariant())[12] {
  static const ScalarVariant values[] = {
    ScalarVariant_NONE,
    ScalarVariant_ByteArray,
    ScalarVariant_Int8,
    ScalarVariant_UInt8,
    ScalarVariant_Int16,
    ScalarVariant_UInt16,
    ScalarVariant_Int32,
    ScalarVariant_UInt32,
    ScalarVariant_Int64,
    ScalarVariant_UInt64,
    ScalarVariant_Float32,
    ScalarVariant_Float64
  };
  return values;
}

inline const char * const *EnumNamesScalarVariant() {
  static const char * const names[13] = {
    "NONE",
    "ByteArray",
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarVariant(ScalarVariant e) {
  if (flatbuffers::IsOutRange(e, ScalarVariant_NONE, ScalarVariant_Float64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarVariant()[index];
}

template<typename T> struct ScalarVariantTraits {
  static const ScalarVariant enum_value = ScalarVariant_NONE;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::ByteArray> {
  static const ScalarVariant enum_value = ScalarVariant_ByteArray;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int8> {
  static const ScalarVariant enum_value = ScalarVariant_Int8;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt8> {
  static const ScalarVariant enum_value = ScalarVariant_UInt8;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int16> {
  static const ScalarVariant enum_value = ScalarVariant_Int16;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt16> {
  static const ScalarVariant enum_value = ScalarVariant_UInt16;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int32> {
  static const ScalarVariant enum_value = ScalarVariant_Int32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt32> {
  static const ScalarVariant enum_value = ScalarVariant_UInt32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int64> {
  static const ScalarVariant enum_value = ScalarVariant_Int64;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt64> {
  static const ScalarVariant enum_value = ScalarVariant_UInt64;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Float32> {
  static const ScalarVariant enum_value = ScalarVariant_Float32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Float64> {
  static const ScalarVariant enum_value = ScalarVariant_Float64;
};

bool VerifyScalarVariant(flatbuffers::Verifier &verifier, const void *obj, ScalarVariant type);
bool VerifyScalarVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) UInt8 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_;

 public:
  UInt8() {
    memset(static_cast<void *>(this), 0, sizeof(UInt8));
  }
  UInt8(uint8_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  uint8_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint8_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt8, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) UInt16 FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t data_;

 public:
  UInt16() {
    memset(static_cast<void *>(this), 0, sizeof(UInt16));
  }
  UInt16(uint16_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  uint16_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint16_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt16, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UInt32 FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t data_;

 public:
  UInt32() {
    memset(static_cast<void *>(this), 0, sizeof(UInt32));
  }
  UInt32(uint32_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  uint32_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint32_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UInt64 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t data_;

 public:
  UInt64() {
    memset(static_cast<void *>(this), 0, sizeof(UInt64));
  }
  UInt64(uint64_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  uint64_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint64_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Int8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t data_;

 public:
  Int8() {
    memset(static_cast<void *>(this), 0, sizeof(Int8));
  }
  Int8(int8_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int8_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int8_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int8, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Int16 FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t data_;

 public:
  Int16() {
    memset(static_cast<void *>(this), 0, sizeof(Int16));
  }
  Int16(int16_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int16_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int16_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int16, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Int32 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t data_;

 public:
  Int32() {
    memset(static_cast<void *>(this), 0, sizeof(Int32));
  }
  Int32(int32_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int32_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int32_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Int64 FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t data_;

 public:
  Int64() {
    memset(static_cast<void *>(this), 0, sizeof(Int64));
  }
  Int64(int64_t _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  int64_t data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int64_t _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float32 FLATBUFFERS_FINAL_CLASS {
 private:
  float data_;

 public:
  Float32() {
    memset(static_cast<void *>(this), 0, sizeof(Float32));
  }
  Float32(float _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  float data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(float _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Float32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Float64 FLATBUFFERS_FINAL_CLASS {
 private:
  double data_;

 public:
  Float64() {
    memset(static_cast<void *>(this), 0, sizeof(Float64));
  }
  Float64(double _data)
      : data_(flatbuffers::EndianScalar(_data)) {
  }
  double data() const {
    return flatbuffers::EndianScalar(data_);
  }
  void mutate_data(double _data) {
    flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Float64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ScaleBias FLATBUFFERS_FINAL_CLASS {
 private:
  float scale_;
  float bias_;

 public:
  ScaleBias() {
    memset(static_cast<void *>(this), 0, sizeof(ScaleBias));
  }
  ScaleBias(float _scale, float _bias)
      : scale_(flatbuffers::EndianScalar(_scale)),
        bias_(flatbuffers::EndianScalar(_bias)) {
  }
  float scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
  void mutate_scale(float _scale) {
    flatbuffers::WriteScalar(&scale_, _scale);
  }
  float bias() const {
    return flatbuffers::EndianScalar(bias_);
  }
  void mutate_bias(float _bias) {
    flatbuffers::WriteScalar(&bias_, _bias);
  }
};
FLATBUFFERS_STRUCT_END(ScaleBias, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Size2D FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t width_;
  uint32_t height_;

 public:
  Size2D() {
    memset(static_cast<void *>(this), 0, sizeof(Size2D));
  }
  Size2D(uint32_t _width, uint32_t _height)
      : width_(flatbuffers::EndianScalar(_width)),
        height_(flatbuffers::EndianScalar(_height)) {
  }
  uint32_t width() const {
    return flatbuffers::EndianScalar(width_);
  }
  void mutate_width(uint32_t _width) {
    flatbuffers::WriteScalar(&width_, _width);
  }
  uint32_t height() const {
    return flatbuffers::EndianScalar(height_);
  }
  void mutate_height(uint32_t _height) {
    flatbuffers::WriteScalar(&height_, _height);
  }
};
FLATBUFFERS_STRUCT_END(Size2D, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ByteArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_[8];

 public:
  ByteArray() {
    memset(static_cast<void *>(this), 0, sizeof(ByteArray));
  }
  const flatbuffers::Array<uint8_t, 8> *data() const {
    return reinterpret_cast<const flatbuffers::Array<uint8_t, 8> *>(data_);
  }
  flatbuffers::Array<uint8_t, 8> *mutable_data() {
    return reinterpret_cast<flatbuffers::Array<uint8_t, 8> *>(data_);
  }
};
FLATBUFFERS_STRUCT_END(ByteArray, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_;

 public:
  Bool() {
    memset(static_cast<void *>(this), 0, sizeof(Bool));
  }
  Bool(bool _data)
      : data_(flatbuffers::EndianScalar(static_cast<uint8_t>(_data))) {
  }
  bool data() const {
    return flatbuffers::EndianScalar(data_) != 0;
  }
  void mutate_data(bool _data) {
    flatbuffers::WriteScalar(&data_, static_cast<uint8_t>(_data));
  }
};
FLATBUFFERS_STRUCT_END(Bool, 1);

struct AttributeDesc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VAL_TYPE = 6,
    VT_VAL = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  dml::ir::operatorFieldTypes::AttributeFieldVariant val_type() const {
    return static_cast<dml::ir::operatorFieldTypes::AttributeFieldVariant>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const dml::ir::operatorFieldTypes::Activation *val_as_Activation() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Activation ? static_cast<const dml::ir::operatorFieldTypes::Activation *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ActivationArray *val_as_ActivationArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ActivationArray ? static_cast<const dml::ir::operatorFieldTypes::ActivationArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt32 *val_as_UInt32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UInt32 ? static_cast<const dml::ir::operatorFieldTypes::UInt32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt64 *val_as_UInt64() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UInt64 ? static_cast<const dml::ir::operatorFieldTypes::UInt64 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int32 *val_as_Int32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Int32 ? static_cast<const dml::ir::operatorFieldTypes::Int32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float32 *val_as_Float32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Float32 ? static_cast<const dml::ir::operatorFieldTypes::Float32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UIntArray *val_as_UIntArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UIntArray ? static_cast<const dml::ir::operatorFieldTypes::UIntArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::IntArray *val_as_IntArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_IntArray ? static_cast<const dml::ir::operatorFieldTypes::IntArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::FloatArray *val_as_FloatArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_FloatArray ? static_cast<const dml::ir::operatorFieldTypes::FloatArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ScaleBias *val_as_ScaleBias() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ScaleBias ? static_cast<const dml::ir::operatorFieldTypes::ScaleBias *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Size2D *val_as_Size2D() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Size2D ? static_cast<const dml::ir::operatorFieldTypes::Size2D *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ScalarUnionData *val_as_ScalarUnionData() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ScalarUnionData ? static_cast<const dml::ir::operatorFieldTypes::ScalarUnionData *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Bool *val_as_Bool() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Bool ? static_cast<const dml::ir::operatorFieldTypes::Bool *>(val()) : nullptr;
  }
  void *mutable_val() {
    return GetPointer<void *>(VT_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyAttributeFieldVariant(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dml::ir::operatorFieldTypes::Activation *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Activation>() const {
  return val_as_Activation();
}

template<> inline const dml::ir::operatorFieldTypes::ActivationArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ActivationArray>() const {
  return val_as_ActivationArray();
}

template<> inline const dml::ir::operatorFieldTypes::UInt32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UInt32>() const {
  return val_as_UInt32();
}

template<> inline const dml::ir::operatorFieldTypes::UInt64 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UInt64>() const {
  return val_as_UInt64();
}

template<> inline const dml::ir::operatorFieldTypes::Int32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Int32>() const {
  return val_as_Int32();
}

template<> inline const dml::ir::operatorFieldTypes::Float32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Float32>() const {
  return val_as_Float32();
}

template<> inline const dml::ir::operatorFieldTypes::UIntArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UIntArray>() const {
  return val_as_UIntArray();
}

template<> inline const dml::ir::operatorFieldTypes::IntArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::IntArray>() const {
  return val_as_IntArray();
}

template<> inline const dml::ir::operatorFieldTypes::FloatArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::FloatArray>() const {
  return val_as_FloatArray();
}

template<> inline const dml::ir::operatorFieldTypes::ScaleBias *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ScaleBias>() const {
  return val_as_ScaleBias();
}

template<> inline const dml::ir::operatorFieldTypes::Size2D *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Size2D>() const {
  return val_as_Size2D();
}

template<> inline const dml::ir::operatorFieldTypes::ScalarUnionData *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ScalarUnionData>() const {
  return val_as_ScalarUnionData();
}

template<> inline const dml::ir::operatorFieldTypes::Bool *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Bool>() const {
  return val_as_Bool();
}

struct AttributeDescBuilder {
  typedef AttributeDesc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AttributeDesc::VT_NAME, name);
  }
  void add_val_type(dml::ir::operatorFieldTypes::AttributeFieldVariant val_type) {
    fbb_.AddElement<uint8_t>(AttributeDesc::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(flatbuffers::Offset<void> val) {
    fbb_.AddOffset(AttributeDesc::VT_VAL, val);
  }
  explicit AttributeDescBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeDescBuilder &operator=(const AttributeDescBuilder &);
  flatbuffers::Offset<AttributeDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeDesc>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeDesc> CreateAttributeDesc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    dml::ir::operatorFieldTypes::AttributeFieldVariant val_type = dml::ir::operatorFieldTypes::AttributeFieldVariant_NONE,
    flatbuffers::Offset<void> val = 0) {
  AttributeDescBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_name(name);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeDesc> CreateAttributeDescDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    dml::ir::operatorFieldTypes::AttributeFieldVariant val_type = dml::ir::operatorFieldTypes::AttributeFieldVariant_NONE,
    flatbuffers::Offset<void> val = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return dml::ir::operatorFieldTypes::CreateAttributeDesc(
      _fbb,
      name__,
      val_type,
      val);
}

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTRIBUTES = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *>(VT_ATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *mutable_attributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *>(VT_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct ActivationBuilder {
  typedef Activation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Activation::VT_TYPE, type);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>> attributes) {
    fbb_.AddOffset(Activation::VT_ATTRIBUTES, attributes);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationBuilder &operator=(const ActivationBuilder &);
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>> attributes = 0) {
  ActivationBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Activation> CreateActivationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *attributes = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>(*attributes) : 0;
  return dml::ir::operatorFieldTypes::CreateActivation(
      _fbb,
      type__,
      attributes__);
}

struct ActivationArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *>(VT_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *mutable_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct ActivationArrayBuilder {
  typedef ActivationArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>> data) {
    fbb_.AddOffset(ActivationArray::VT_DATA, data);
  }
  explicit ActivationArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationArrayBuilder &operator=(const ActivationArrayBuilder &);
  flatbuffers::Offset<ActivationArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationArray> CreateActivationArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>> data = 0) {
  ActivationArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActivationArray> CreateActivationArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateActivationArray(
      _fbb,
      data__);
}

struct UIntArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIntArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint32_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct UIntArrayBuilder {
  typedef UIntArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(UIntArray::VT_DATA, data);
  }
  explicit UIntArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UIntArrayBuilder &operator=(const UIntArrayBuilder &);
  flatbuffers::Offset<UIntArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIntArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIntArray> CreateUIntArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  UIntArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIntArray> CreateUIntArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateUIntArray(
      _fbb,
      data__);
}

struct IntArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  flatbuffers::Vector<int32_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct IntArrayBuilder {
  typedef IntArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(IntArray::VT_DATA, data);
  }
  explicit IntArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntArrayBuilder &operator=(const IntArrayBuilder &);
  flatbuffers::Offset<IntArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntArray> CreateIntArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  IntArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntArray> CreateIntArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateIntArray(
      _fbb,
      data__);
}

struct FloatArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloatArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  flatbuffers::Vector<float> *mutable_data() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct FloatArrayBuilder {
  typedef FloatArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(FloatArray::VT_DATA, data);
  }
  explicit FloatArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatArrayBuilder &operator=(const FloatArrayBuilder &);
  flatbuffers::Offset<FloatArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatArray> CreateFloatArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  FloatArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatArray> CreateFloatArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateFloatArray(
      _fbb,
      data__);
}

struct ScalarUnionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScalarUnionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  dml::ir::operatorFieldTypes::ScalarVariant data_type() const {
    return static_cast<dml::ir::operatorFieldTypes::ScalarVariant>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const dml::ir::operatorFieldTypes::ByteArray *data_as_ByteArray() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_ByteArray ? static_cast<const dml::ir::operatorFieldTypes::ByteArray *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int8 *data_as_Int8() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int8 ? static_cast<const dml::ir::operatorFieldTypes::Int8 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt8 *data_as_UInt8() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt8 ? static_cast<const dml::ir::operatorFieldTypes::UInt8 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int16 *data_as_Int16() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int16 ? static_cast<const dml::ir::operatorFieldTypes::Int16 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt16 *data_as_UInt16() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt16 ? static_cast<const dml::ir::operatorFieldTypes::UInt16 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int32 *data_as_Int32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int32 ? static_cast<const dml::ir::operatorFieldTypes::Int32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt32 *data_as_UInt32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt32 ? static_cast<const dml::ir::operatorFieldTypes::UInt32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int64 *data_as_Int64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int64 ? static_cast<const dml::ir::operatorFieldTypes::Int64 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt64 *data_as_UInt64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt64 ? static_cast<const dml::ir::operatorFieldTypes::UInt64 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float32 *data_as_Float32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Float32 ? static_cast<const dml::ir::operatorFieldTypes::Float32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float64 *data_as_Float64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Float64 ? static_cast<const dml::ir::operatorFieldTypes::Float64 *>(data()) : nullptr;
  }
  void *mutable_data() {
    return GetPointer<void *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyScalarVariant(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dml::ir::operatorFieldTypes::ByteArray *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::ByteArray>() const {
  return data_as_ByteArray();
}

template<> inline const dml::ir::operatorFieldTypes::Int8 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int8>() const {
  return data_as_Int8();
}

template<> inline const dml::ir::operatorFieldTypes::UInt8 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt8>() const {
  return data_as_UInt8();
}

template<> inline const dml::ir::operatorFieldTypes::Int16 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int16>() const {
  return data_as_Int16();
}

template<> inline const dml::ir::operatorFieldTypes::UInt16 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt16>() const {
  return data_as_UInt16();
}

template<> inline const dml::ir::operatorFieldTypes::Int32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int32>() const {
  return data_as_Int32();
}

template<> inline const dml::ir::operatorFieldTypes::UInt32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt32>() const {
  return data_as_UInt32();
}

template<> inline const dml::ir::operatorFieldTypes::Int64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int64>() const {
  return data_as_Int64();
}

template<> inline const dml::ir::operatorFieldTypes::UInt64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt64>() const {
  return data_as_UInt64();
}

template<> inline const dml::ir::operatorFieldTypes::Float32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Float32>() const {
  return data_as_Float32();
}

template<> inline const dml::ir::operatorFieldTypes::Float64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Float64>() const {
  return data_as_Float64();
}

struct ScalarUnionDataBuilder {
  typedef ScalarUnionData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(dml::ir::operatorFieldTypes::ScalarVariant data_type) {
    fbb_.AddElement<uint8_t>(ScalarUnionData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(ScalarUnionData::VT_DATA, data);
  }
  explicit ScalarUnionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScalarUnionDataBuilder &operator=(const ScalarUnionDataBuilder &);
  flatbuffers::Offset<ScalarUnionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScalarUnionData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScalarUnionData> CreateScalarUnionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    dml::ir::operatorFieldTypes::ScalarVariant data_type = dml::ir::operatorFieldTypes::ScalarVariant_NONE,
    flatbuffers::Offset<void> data = 0) {
  ScalarUnionDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyAttributeFieldVariant(flatbuffers::Verifier &verifier, const void *obj, AttributeFieldVariant type) {
  switch (type) {
    case AttributeFieldVariant_NONE: {
      return true;
    }
    case AttributeFieldVariant_Activation: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_ActivationArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::ActivationArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_UInt32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt32>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_UInt64: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt64>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_Int32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Int32>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_Float32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Float32>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_UIntArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::UIntArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_IntArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::IntArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_FloatArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::FloatArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_ScaleBias: {
      return verifier.Verify<dml::ir::operatorFieldTypes::ScaleBias>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_Size2D: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Size2D>(static_cast<const uint8_t *>(obj), 0);
    }
    case AttributeFieldVariant_ScalarUnionData: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::ScalarUnionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_Bool: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Bool>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyAttributeFieldVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAttributeFieldVariant(
        verifier,  values->Get(i), types->GetEnum<AttributeFieldVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScalarVariant(flatbuffers::Verifier &verifier, const void *obj, ScalarVariant type) {
  switch (type) {
    case ScalarVariant_NONE: {
      return true;
    }
    case ScalarVariant_ByteArray: {
      return verifier.Verify<dml::ir::operatorFieldTypes::ByteArray>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Int8: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Int8>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_UInt8: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt8>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Int16: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Int16>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_UInt16: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt16>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Int32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Int32>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_UInt32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt32>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Int64: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Int64>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_UInt64: {
      return verifier.Verify<dml::ir::operatorFieldTypes::UInt64>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Float32: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Float32>(static_cast<const uint8_t *>(obj), 0);
    }
    case ScalarVariant_Float64: {
      return verifier.Verify<dml::ir::operatorFieldTypes::Float64>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyScalarVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarVariant(
        verifier,  values->Get(i), types->GetEnum<ScalarVariant>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace operatorFieldTypes
}  // namespace ir
}  // namespace dml

#endif  // FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_
