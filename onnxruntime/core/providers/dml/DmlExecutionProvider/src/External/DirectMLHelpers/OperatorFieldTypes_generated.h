// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_
#define FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_

#include "core/common/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace dml {
namespace ir {
namespace operatorFieldTypes {

struct AttributeDesc;
struct AttributeDescBuilder;

struct Activation;
struct ActivationBuilder;

struct ActivationArray;
struct ActivationArrayBuilder;

struct UInt8;

struct UInt16;

struct UInt32;

struct UInt64;

struct Int8;

struct Int16;

struct Int32;

struct Int64;

struct Float32;

struct Float64;

struct UIntArray;
struct UIntArrayBuilder;

struct IntArray;
struct IntArrayBuilder;

struct FloatArray;
struct FloatArrayBuilder;

struct ScaleBias;

struct Size2D;

struct ByteArray;

struct ScalarUnionData;
struct ScalarUnionDataBuilder;

struct Bool;

enum AttributeFieldVariant : uint8_t {
  AttributeFieldVariant_NONE = 0,
  AttributeFieldVariant_Activation = 1,
  AttributeFieldVariant_ActivationArray = 2,
  AttributeFieldVariant_UInt32 = 3,
  AttributeFieldVariant_UInt64 = 4,
  AttributeFieldVariant_Int32 = 5,
  AttributeFieldVariant_Float32 = 6,
  AttributeFieldVariant_UIntArray = 7,
  AttributeFieldVariant_IntArray = 8,
  AttributeFieldVariant_FloatArray = 9,
  AttributeFieldVariant_ScaleBias = 10,
  AttributeFieldVariant_Size2D = 11,
  AttributeFieldVariant_ScalarUnionData = 12,
  AttributeFieldVariant_Bool = 13,
  AttributeFieldVariant_MIN = AttributeFieldVariant_NONE,
  AttributeFieldVariant_MAX = AttributeFieldVariant_Bool
};

inline const AttributeFieldVariant (&EnumValuesAttributeFieldVariant())[14] {
  static const AttributeFieldVariant values[] = {
    AttributeFieldVariant_NONE,
    AttributeFieldVariant_Activation,
    AttributeFieldVariant_ActivationArray,
    AttributeFieldVariant_UInt32,
    AttributeFieldVariant_UInt64,
    AttributeFieldVariant_Int32,
    AttributeFieldVariant_Float32,
    AttributeFieldVariant_UIntArray,
    AttributeFieldVariant_IntArray,
    AttributeFieldVariant_FloatArray,
    AttributeFieldVariant_ScaleBias,
    AttributeFieldVariant_Size2D,
    AttributeFieldVariant_ScalarUnionData,
    AttributeFieldVariant_Bool
  };
  return values;
}

inline const char * const *EnumNamesAttributeFieldVariant() {
  static const char * const names[15] = {
    "NONE",
    "Activation",
    "ActivationArray",
    "UInt32",
    "UInt64",
    "Int32",
    "Float32",
    "UIntArray",
    "IntArray",
    "FloatArray",
    "ScaleBias",
    "Size2D",
    "ScalarUnionData",
    "Bool",
    nullptr
  };
  return names;
}

inline const char *EnumNameAttributeFieldVariant(AttributeFieldVariant e) {
  if (::flatbuffers::IsOutRange(e, AttributeFieldVariant_NONE, AttributeFieldVariant_Bool)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAttributeFieldVariant()[index];
}

template<typename T> struct AttributeFieldVariantTraits {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_NONE;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Activation> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Activation;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ActivationArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ActivationArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UInt32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UInt32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UInt64> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UInt64;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Int32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Int32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Float32> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Float32;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::UIntArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_UIntArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::IntArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_IntArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::FloatArray> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_FloatArray;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ScaleBias> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ScaleBias;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Size2D> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Size2D;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::ScalarUnionData> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_ScalarUnionData;
};

template<> struct AttributeFieldVariantTraits<dml::ir::operatorFieldTypes::Bool> {
  static const AttributeFieldVariant enum_value = AttributeFieldVariant_Bool;
};

bool VerifyAttributeFieldVariant(::flatbuffers::Verifier &verifier, const void *obj, AttributeFieldVariant type);
bool VerifyAttributeFieldVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ScalarVariant : uint8_t {
  ScalarVariant_NONE = 0,
  ScalarVariant_ByteArray = 1,
  ScalarVariant_Int8 = 2,
  ScalarVariant_UInt8 = 3,
  ScalarVariant_Int16 = 4,
  ScalarVariant_UInt16 = 5,
  ScalarVariant_Int32 = 6,
  ScalarVariant_UInt32 = 7,
  ScalarVariant_Int64 = 8,
  ScalarVariant_UInt64 = 9,
  ScalarVariant_Float32 = 10,
  ScalarVariant_Float64 = 11,
  ScalarVariant_MIN = ScalarVariant_NONE,
  ScalarVariant_MAX = ScalarVariant_Float64
};

inline const ScalarVariant (&EnumValuesScalarVariant())[12] {
  static const ScalarVariant values[] = {
    ScalarVariant_NONE,
    ScalarVariant_ByteArray,
    ScalarVariant_Int8,
    ScalarVariant_UInt8,
    ScalarVariant_Int16,
    ScalarVariant_UInt16,
    ScalarVariant_Int32,
    ScalarVariant_UInt32,
    ScalarVariant_Int64,
    ScalarVariant_UInt64,
    ScalarVariant_Float32,
    ScalarVariant_Float64
  };
  return values;
}

inline const char * const *EnumNamesScalarVariant() {
  static const char * const names[13] = {
    "NONE",
    "ByteArray",
    "Int8",
    "UInt8",
    "Int16",
    "UInt16",
    "Int32",
    "UInt32",
    "Int64",
    "UInt64",
    "Float32",
    "Float64",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarVariant(ScalarVariant e) {
  if (::flatbuffers::IsOutRange(e, ScalarVariant_NONE, ScalarVariant_Float64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarVariant()[index];
}

template<typename T> struct ScalarVariantTraits {
  static const ScalarVariant enum_value = ScalarVariant_NONE;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::ByteArray> {
  static const ScalarVariant enum_value = ScalarVariant_ByteArray;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int8> {
  static const ScalarVariant enum_value = ScalarVariant_Int8;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt8> {
  static const ScalarVariant enum_value = ScalarVariant_UInt8;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int16> {
  static const ScalarVariant enum_value = ScalarVariant_Int16;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt16> {
  static const ScalarVariant enum_value = ScalarVariant_UInt16;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int32> {
  static const ScalarVariant enum_value = ScalarVariant_Int32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt32> {
  static const ScalarVariant enum_value = ScalarVariant_UInt32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Int64> {
  static const ScalarVariant enum_value = ScalarVariant_Int64;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::UInt64> {
  static const ScalarVariant enum_value = ScalarVariant_UInt64;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Float32> {
  static const ScalarVariant enum_value = ScalarVariant_Float32;
};

template<> struct ScalarVariantTraits<dml::ir::operatorFieldTypes::Float64> {
  static const ScalarVariant enum_value = ScalarVariant_Float64;
};

bool VerifyScalarVariant(::flatbuffers::Verifier &verifier, const void *obj, ScalarVariant type);
bool VerifyScalarVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) UInt8 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_;

 public:
  UInt8()
      : data_(0) {
  }
  UInt8(uint8_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  uint8_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint8_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt8, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) UInt16 FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t data_;

 public:
  UInt16()
      : data_(0) {
  }
  UInt16(uint16_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  uint16_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint16_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt16, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UInt32 FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t data_;

 public:
  UInt32()
      : data_(0) {
  }
  UInt32(uint32_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  uint32_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint32_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UInt64 FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t data_;

 public:
  UInt64()
      : data_(0) {
  }
  UInt64(uint64_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  uint64_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(uint64_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(UInt64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Int8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t data_;

 public:
  Int8()
      : data_(0) {
  }
  Int8(int8_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  int8_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int8_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int8, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Int16 FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t data_;

 public:
  Int16()
      : data_(0) {
  }
  Int16(int16_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  int16_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int16_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int16, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Int32 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t data_;

 public:
  Int32()
      : data_(0) {
  }
  Int32(int32_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  int32_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int32_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Int64 FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t data_;

 public:
  Int64()
      : data_(0) {
  }
  Int64(int64_t _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  int64_t data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(int64_t _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Int64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float32 FLATBUFFERS_FINAL_CLASS {
 private:
  float data_;

 public:
  Float32()
      : data_(0) {
  }
  Float32(float _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  float data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(float _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Float32, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Float64 FLATBUFFERS_FINAL_CLASS {
 private:
  double data_;

 public:
  Float64()
      : data_(0) {
  }
  Float64(double _data)
      : data_(::flatbuffers::EndianScalar(_data)) {
  }
  double data() const {
    return ::flatbuffers::EndianScalar(data_);
  }
  void mutate_data(double _data) {
    ::flatbuffers::WriteScalar(&data_, _data);
  }
};
FLATBUFFERS_STRUCT_END(Float64, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ScaleBias FLATBUFFERS_FINAL_CLASS {
 private:
  float scale_;
  float bias_;

 public:
  ScaleBias()
      : scale_(0),
        bias_(0) {
  }
  ScaleBias(float _scale, float _bias)
      : scale_(::flatbuffers::EndianScalar(_scale)),
        bias_(::flatbuffers::EndianScalar(_bias)) {
  }
  float scale() const {
    return ::flatbuffers::EndianScalar(scale_);
  }
  void mutate_scale(float _scale) {
    ::flatbuffers::WriteScalar(&scale_, _scale);
  }
  float bias() const {
    return ::flatbuffers::EndianScalar(bias_);
  }
  void mutate_bias(float _bias) {
    ::flatbuffers::WriteScalar(&bias_, _bias);
  }
};
FLATBUFFERS_STRUCT_END(ScaleBias, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Size2D FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t width_;
  uint32_t height_;

 public:
  Size2D()
      : width_(0),
        height_(0) {
  }
  Size2D(uint32_t _width, uint32_t _height)
      : width_(::flatbuffers::EndianScalar(_width)),
        height_(::flatbuffers::EndianScalar(_height)) {
  }
  uint32_t width() const {
    return ::flatbuffers::EndianScalar(width_);
  }
  void mutate_width(uint32_t _width) {
    ::flatbuffers::WriteScalar(&width_, _width);
  }
  uint32_t height() const {
    return ::flatbuffers::EndianScalar(height_);
  }
  void mutate_height(uint32_t _height) {
    ::flatbuffers::WriteScalar(&height_, _height);
  }
};
FLATBUFFERS_STRUCT_END(Size2D, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ByteArray FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_[8];

 public:
  ByteArray()
      : data_() {
  }
  ByteArray(::flatbuffers::span<const uint8_t, 8> _data) {
    ::flatbuffers::CastToArray(data_).CopyFromSpan(_data);
  }
  const ::flatbuffers::Array<uint8_t, 8> *data() const {
    return &::flatbuffers::CastToArray(data_);
  }
  ::flatbuffers::Array<uint8_t, 8> *mutable_data() {
    return &::flatbuffers::CastToArray(data_);
  }
};
FLATBUFFERS_STRUCT_END(ByteArray, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_;

 public:
  Bool()
      : data_(0) {
  }
  Bool(bool _data)
      : data_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_data))) {
  }
  bool data() const {
    return ::flatbuffers::EndianScalar(data_) != 0;
  }
  void mutate_data(bool _data) {
    ::flatbuffers::WriteScalar(&data_, static_cast<uint8_t>(_data));
  }
};
FLATBUFFERS_STRUCT_END(Bool, 1);

struct AttributeDesc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VAL_TYPE = 6,
    VT_VAL = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  dml::ir::operatorFieldTypes::AttributeFieldVariant val_type() const {
    return static_cast<dml::ir::operatorFieldTypes::AttributeFieldVariant>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const dml::ir::operatorFieldTypes::Activation *val_as_Activation() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Activation ? static_cast<const dml::ir::operatorFieldTypes::Activation *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ActivationArray *val_as_ActivationArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ActivationArray ? static_cast<const dml::ir::operatorFieldTypes::ActivationArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt32 *val_as_UInt32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UInt32 ? static_cast<const dml::ir::operatorFieldTypes::UInt32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt64 *val_as_UInt64() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UInt64 ? static_cast<const dml::ir::operatorFieldTypes::UInt64 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int32 *val_as_Int32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Int32 ? static_cast<const dml::ir::operatorFieldTypes::Int32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float32 *val_as_Float32() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Float32 ? static_cast<const dml::ir::operatorFieldTypes::Float32 *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UIntArray *val_as_UIntArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_UIntArray ? static_cast<const dml::ir::operatorFieldTypes::UIntArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::IntArray *val_as_IntArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_IntArray ? static_cast<const dml::ir::operatorFieldTypes::IntArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::FloatArray *val_as_FloatArray() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_FloatArray ? static_cast<const dml::ir::operatorFieldTypes::FloatArray *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ScaleBias *val_as_ScaleBias() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ScaleBias ? static_cast<const dml::ir::operatorFieldTypes::ScaleBias *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Size2D *val_as_Size2D() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Size2D ? static_cast<const dml::ir::operatorFieldTypes::Size2D *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::ScalarUnionData *val_as_ScalarUnionData() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_ScalarUnionData ? static_cast<const dml::ir::operatorFieldTypes::ScalarUnionData *>(val()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Bool *val_as_Bool() const {
    return val_type() == dml::ir::operatorFieldTypes::AttributeFieldVariant_Bool ? static_cast<const dml::ir::operatorFieldTypes::Bool *>(val()) : nullptr;
  }
  void *mutable_val() {
    return GetPointer<void *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyAttributeFieldVariant(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dml::ir::operatorFieldTypes::Activation *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Activation>() const {
  return val_as_Activation();
}

template<> inline const dml::ir::operatorFieldTypes::ActivationArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ActivationArray>() const {
  return val_as_ActivationArray();
}

template<> inline const dml::ir::operatorFieldTypes::UInt32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UInt32>() const {
  return val_as_UInt32();
}

template<> inline const dml::ir::operatorFieldTypes::UInt64 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UInt64>() const {
  return val_as_UInt64();
}

template<> inline const dml::ir::operatorFieldTypes::Int32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Int32>() const {
  return val_as_Int32();
}

template<> inline const dml::ir::operatorFieldTypes::Float32 *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Float32>() const {
  return val_as_Float32();
}

template<> inline const dml::ir::operatorFieldTypes::UIntArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::UIntArray>() const {
  return val_as_UIntArray();
}

template<> inline const dml::ir::operatorFieldTypes::IntArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::IntArray>() const {
  return val_as_IntArray();
}

template<> inline const dml::ir::operatorFieldTypes::FloatArray *AttributeDesc::val_as<dml::ir::operatorFieldTypes::FloatArray>() const {
  return val_as_FloatArray();
}

template<> inline const dml::ir::operatorFieldTypes::ScaleBias *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ScaleBias>() const {
  return val_as_ScaleBias();
}

template<> inline const dml::ir::operatorFieldTypes::Size2D *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Size2D>() const {
  return val_as_Size2D();
}

template<> inline const dml::ir::operatorFieldTypes::ScalarUnionData *AttributeDesc::val_as<dml::ir::operatorFieldTypes::ScalarUnionData>() const {
  return val_as_ScalarUnionData();
}

template<> inline const dml::ir::operatorFieldTypes::Bool *AttributeDesc::val_as<dml::ir::operatorFieldTypes::Bool>() const {
  return val_as_Bool();
}

struct AttributeDescBuilder {
  typedef AttributeDesc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AttributeDesc::VT_NAME, name);
  }
  void add_val_type(dml::ir::operatorFieldTypes::AttributeFieldVariant val_type) {
    fbb_.AddElement<uint8_t>(AttributeDesc::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(AttributeDesc::VT_VAL, val);
  }
  explicit AttributeDescBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttributeDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttributeDesc>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AttributeDesc> CreateAttributeDesc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    dml::ir::operatorFieldTypes::AttributeFieldVariant val_type = dml::ir::operatorFieldTypes::AttributeFieldVariant_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  AttributeDescBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_name(name);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AttributeDesc> CreateAttributeDescDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    dml::ir::operatorFieldTypes::AttributeFieldVariant val_type = dml::ir::operatorFieldTypes::AttributeFieldVariant_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return dml::ir::operatorFieldTypes::CreateAttributeDesc(
      _fbb,
      name__,
      val_type,
      val);
}

struct Activation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActivationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTRIBUTES = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  ::flatbuffers::String *mutable_type() {
    return GetPointer<::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *>(VT_ATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *mutable_attributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *>(VT_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct ActivationBuilder {
  typedef Activation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Activation::VT_TYPE, type);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>> attributes) {
    fbb_.AddOffset(Activation::VT_ATTRIBUTES, attributes);
  }
  explicit ActivationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Activation> CreateActivation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>> attributes = 0) {
  ActivationBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Activation> CreateActivationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>> *attributes = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::AttributeDesc>>(*attributes) : 0;
  return dml::ir::operatorFieldTypes::CreateActivation(
      _fbb,
      type__,
      attributes__);
}

struct ActivationArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActivationArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *>(VT_DATA);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct ActivationArrayBuilder {
  typedef ActivationArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>> data) {
    fbb_.AddOffset(ActivationArray::VT_DATA, data);
  }
  explicit ActivationArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActivationArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActivationArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActivationArray> CreateActivationArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>> data = 0) {
  ActivationArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ActivationArray> CreateActivationArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<dml::ir::operatorFieldTypes::Activation>>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateActivationArray(
      _fbb,
      data__);
}

struct UIntArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UIntArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct UIntArrayBuilder {
  typedef UIntArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(UIntArray::VT_DATA, data);
  }
  explicit UIntArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UIntArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UIntArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UIntArray> CreateUIntArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> data = 0) {
  UIntArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UIntArray> CreateUIntArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateUIntArray(
      _fbb,
      data__);
}

struct IntArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<int32_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct IntArrayBuilder {
  typedef IntArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(IntArray::VT_DATA, data);
  }
  explicit IntArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntArray> CreateIntArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> data = 0) {
  IntArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntArray> CreateIntArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateIntArray(
      _fbb,
      data__);
}

struct FloatArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<float> *data() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_DATA);
  }
  ::flatbuffers::Vector<float> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct FloatArrayBuilder {
  typedef FloatArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(FloatArray::VT_DATA, data);
  }
  explicit FloatArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatArray> CreateFloatArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> data = 0) {
  FloatArrayBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatArray> CreateFloatArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return dml::ir::operatorFieldTypes::CreateFloatArray(
      _fbb,
      data__);
}

struct ScalarUnionData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarUnionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  dml::ir::operatorFieldTypes::ScalarVariant data_type() const {
    return static_cast<dml::ir::operatorFieldTypes::ScalarVariant>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const dml::ir::operatorFieldTypes::ByteArray *data_as_ByteArray() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_ByteArray ? static_cast<const dml::ir::operatorFieldTypes::ByteArray *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int8 *data_as_Int8() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int8 ? static_cast<const dml::ir::operatorFieldTypes::Int8 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt8 *data_as_UInt8() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt8 ? static_cast<const dml::ir::operatorFieldTypes::UInt8 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int16 *data_as_Int16() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int16 ? static_cast<const dml::ir::operatorFieldTypes::Int16 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt16 *data_as_UInt16() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt16 ? static_cast<const dml::ir::operatorFieldTypes::UInt16 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int32 *data_as_Int32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int32 ? static_cast<const dml::ir::operatorFieldTypes::Int32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt32 *data_as_UInt32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt32 ? static_cast<const dml::ir::operatorFieldTypes::UInt32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Int64 *data_as_Int64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Int64 ? static_cast<const dml::ir::operatorFieldTypes::Int64 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::UInt64 *data_as_UInt64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_UInt64 ? static_cast<const dml::ir::operatorFieldTypes::UInt64 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float32 *data_as_Float32() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Float32 ? static_cast<const dml::ir::operatorFieldTypes::Float32 *>(data()) : nullptr;
  }
  const dml::ir::operatorFieldTypes::Float64 *data_as_Float64() const {
    return data_type() == dml::ir::operatorFieldTypes::ScalarVariant_Float64 ? static_cast<const dml::ir::operatorFieldTypes::Float64 *>(data()) : nullptr;
  }
  void *mutable_data() {
    return GetPointer<void *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyScalarVariant(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dml::ir::operatorFieldTypes::ByteArray *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::ByteArray>() const {
  return data_as_ByteArray();
}

template<> inline const dml::ir::operatorFieldTypes::Int8 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int8>() const {
  return data_as_Int8();
}

template<> inline const dml::ir::operatorFieldTypes::UInt8 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt8>() const {
  return data_as_UInt8();
}

template<> inline const dml::ir::operatorFieldTypes::Int16 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int16>() const {
  return data_as_Int16();
}

template<> inline const dml::ir::operatorFieldTypes::UInt16 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt16>() const {
  return data_as_UInt16();
}

template<> inline const dml::ir::operatorFieldTypes::Int32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int32>() const {
  return data_as_Int32();
}

template<> inline const dml::ir::operatorFieldTypes::UInt32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt32>() const {
  return data_as_UInt32();
}

template<> inline const dml::ir::operatorFieldTypes::Int64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Int64>() const {
  return data_as_Int64();
}

template<> inline const dml::ir::operatorFieldTypes::UInt64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::UInt64>() const {
  return data_as_UInt64();
}

template<> inline const dml::ir::operatorFieldTypes::Float32 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Float32>() const {
  return data_as_Float32();
}

template<> inline const dml::ir::operatorFieldTypes::Float64 *ScalarUnionData::data_as<dml::ir::operatorFieldTypes::Float64>() const {
  return data_as_Float64();
}

struct ScalarUnionDataBuilder {
  typedef ScalarUnionData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(dml::ir::operatorFieldTypes::ScalarVariant data_type) {
    fbb_.AddElement<uint8_t>(ScalarUnionData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(ScalarUnionData::VT_DATA, data);
  }
  explicit ScalarUnionDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScalarUnionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScalarUnionData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScalarUnionData> CreateScalarUnionData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    dml::ir::operatorFieldTypes::ScalarVariant data_type = dml::ir::operatorFieldTypes::ScalarVariant_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  ScalarUnionDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyAttributeFieldVariant(::flatbuffers::Verifier &verifier, const void *obj, AttributeFieldVariant type) {
  switch (type) {
    case AttributeFieldVariant_NONE: {
      return true;
    }
    case AttributeFieldVariant_Activation: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_ActivationArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::ActivationArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_UInt32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case AttributeFieldVariant_UInt64: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt64>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case AttributeFieldVariant_Int32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Int32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case AttributeFieldVariant_Float32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Float32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case AttributeFieldVariant_UIntArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::UIntArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_IntArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::IntArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_FloatArray: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::FloatArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_ScaleBias: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::ScaleBias>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case AttributeFieldVariant_Size2D: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Size2D>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case AttributeFieldVariant_ScalarUnionData: {
      auto ptr = reinterpret_cast<const dml::ir::operatorFieldTypes::ScalarUnionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AttributeFieldVariant_Bool: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Bool>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    default: return true;
  }
}

inline bool VerifyAttributeFieldVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAttributeFieldVariant(
        verifier,  values->Get(i), types->GetEnum<AttributeFieldVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScalarVariant(::flatbuffers::Verifier &verifier, const void *obj, ScalarVariant type) {
  switch (type) {
    case ScalarVariant_NONE: {
      return true;
    }
    case ScalarVariant_ByteArray: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::ByteArray>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case ScalarVariant_Int8: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Int8>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case ScalarVariant_UInt8: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt8>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case ScalarVariant_Int16: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Int16>(static_cast<const uint8_t *>(obj), 0, 2);
    }
    case ScalarVariant_UInt16: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt16>(static_cast<const uint8_t *>(obj), 0, 2);
    }
    case ScalarVariant_Int32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Int32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ScalarVariant_UInt32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ScalarVariant_Int64: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Int64>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case ScalarVariant_UInt64: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::UInt64>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    case ScalarVariant_Float32: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Float32>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ScalarVariant_Float64: {
      return verifier.VerifyField<dml::ir::operatorFieldTypes::Float64>(static_cast<const uint8_t *>(obj), 0, 8);
    }
    default: return true;
  }
}

inline bool VerifyScalarVariantVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarVariant(
        verifier,  values->Get(i), types->GetEnum<ScalarVariant>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace operatorFieldTypes
}  // namespace ir
}  // namespace dml

#endif  // FLATBUFFERS_GENERATED_OPERATORFIELDTYPES_DML_IR_OPERATORFIELDTYPES_H_
