// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#param n_bits
#param has_zero_points

#include "quantization/matmul_nbits_zero_pt.wgsl.template"

#if n_bits == 4
    alias mul_precision = output_element_t;
    fn DequantizedFrom4BitsTo8Bits(in: vec2<u32>, zero: i32) -> vec4<u32>
    {
        var out = vec4<u32>(0);
        var value_lower = vec4<i32>(unpack4xU8(in[0] & 0x0F0F0F0Fu)) - vec4<i32>(zero);
        var value_upper = vec4<i32>(unpack4xU8((in[0] >> 4) & 0x0F0F0F0Fu)) - vec4<i32>(zero);
        out[0] = pack4xI8(vec4<i32>(value_lower[0], value_upper[0], value_lower[1], value_upper[1]));
        out[1] = pack4xI8(vec4<i32>(value_lower[2], value_upper[2], value_lower[3], value_upper[3]));
        value_lower = vec4<i32>(unpack4xU8(in[1] & 0x0F0F0F0Fu)) - vec4<i32>(zero);
        value_upper = vec4<i32>(unpack4xU8((in[1] >> 4) & 0x0F0F0F0Fu)) - vec4<i32>(zero);
        out[2] = pack4xI8(vec4<i32>(value_lower[0], value_upper[0], value_lower[1], value_upper[1]));
        out[3] = pack4xI8(vec4<i32>(value_lower[2], value_upper[2], value_lower[3], value_upper[3]));
        return out;
    }
#endif

#if n_bits == 8
    // For 8bits, in case data overflow when converting from int32 (output of dot4I8Packed) to f16, we force it convert to f32.
    // Then do the scale. Finally, convert to output element type.
    alias mul_precision = f32;
    fn AlignWithZeroPoint(in: vec4<u32>) -> vec4<u32>
    {
        var out = vec4<u32>(0);
        out[0] = pack4xI8(vec4<i32>(unpack4xU8(in[0])) - vec4<i32>(128));
        out[1] = pack4xI8(vec4<i32>(unpack4xU8(in[1])) - vec4<i32>(128));
        out[2] = pack4xI8(vec4<i32>(unpack4xU8(in[2])) - vec4<i32>(128));
        out[3] = pack4xI8(vec4<i32>(unpack4xU8(in[3])) - vec4<i32>(128));
        return out;
    }
#endif

#if n_bits == 2
    alias mul_precision = output_element_t;
    const lut_size = 256;
    var<workgroup> shm_dequantization_table  : array<u32, lut_size>;
    const q2_dequantization_table = array<u32, lut_size>(
        0xFEFEFEFE,
        0xFEFEFEFF,
        0xFEFEFE00,
        0xFEFEFE01,
        0xFEFEFFFE,
        0xFEFEFFFF,
        0xFEFEFF00,
        0xFEFEFF01,
        0xFEFE00FE,
        0xFEFE00FF,
        0xFEFE0000,
        0xFEFE0001,
        0xFEFE01FE,
        0xFEFE01FF,
        0xFEFE0100,
        0xFEFE0101,
        0xFEFFFEFE,
        0xFEFFFEFF,
        0xFEFFFE00,
        0xFEFFFE01,
        0xFEFFFFFE,
        0xFEFFFFFF,
        0xFEFFFF00,
        0xFEFFFF01,
        0xFEFF00FE,
        0xFEFF00FF,
        0xFEFF0000,
        0xFEFF0001,
        0xFEFF01FE,
        0xFEFF01FF,
        0xFEFF0100,
        0xFEFF0101,
        0xFE00FEFE,
        0xFE00FEFF,
        0xFE00FE00,
        0xFE00FE01,
        0xFE00FFFE,
        0xFE00FFFF,
        0xFE00FF00,
        0xFE00FF01,
        0xFE0000FE,
        0xFE0000FF,
        0xFE000000,
        0xFE000001,
        0xFE0001FE,
        0xFE0001FF,
        0xFE000100,
        0xFE000101,
        0xFE01FEFE,
        0xFE01FEFF,
        0xFE01FE00,
        0xFE01FE01,
        0xFE01FFFE,
        0xFE01FFFF,
        0xFE01FF00,
        0xFE01FF01,
        0xFE0100FE,
        0xFE0100FF,
        0xFE010000,
        0xFE010001,
        0xFE0101FE,
        0xFE0101FF,
        0xFE010100,
        0xFE010101,
        0xFFFEFEFE,
        0xFFFEFEFF,
        0xFFFEFE00,
        0xFFFEFE01,
        0xFFFEFFFE,
        0xFFFEFFFF,
        0xFFFEFF00,
        0xFFFEFF01,
        0xFFFE00FE,
        0xFFFE00FF,
        0xFFFE0000,
        0xFFFE0001,
        0xFFFE01FE,
        0xFFFE01FF,
        0xFFFE0100,
        0xFFFE0101,
        0xFFFFFEFE,
        0xFFFFFEFF,
        0xFFFFFE00,
        0xFFFFFE01,
        0xFFFFFFFE,
        0xFFFFFFFF,
        0xFFFFFF00,
        0xFFFFFF01,
        0xFFFF00FE,
        0xFFFF00FF,
        0xFFFF0000,
        0xFFFF0001,
        0xFFFF01FE,
        0xFFFF01FF,
        0xFFFF0100,
        0xFFFF0101,
        0xFF00FEFE,
        0xFF00FEFF,
        0xFF00FE00,
        0xFF00FE01,
        0xFF00FFFE,
        0xFF00FFFF,
        0xFF00FF00,
        0xFF00FF01,
        0xFF0000FE,
        0xFF0000FF,
        0xFF000000,
        0xFF000001,
        0xFF0001FE,
        0xFF0001FF,
        0xFF000100,
        0xFF000101,
        0xFF01FEFE,
        0xFF01FEFF,
        0xFF01FE00,
        0xFF01FE01,
        0xFF01FFFE,
        0xFF01FFFF,
        0xFF01FF00,
        0xFF01FF01,
        0xFF0100FE,
        0xFF0100FF,
        0xFF010000,
        0xFF010001,
        0xFF0101FE,
        0xFF0101FF,
        0xFF010100,
        0xFF010101,
        0x00FEFEFE,
        0x00FEFEFF,
        0x00FEFE00,
        0x00FEFE01,
        0x00FEFFFE,
        0x00FEFFFF,
        0x00FEFF00,
        0x00FEFF01,
        0x00FE00FE,
        0x00FE00FF,
        0x00FE0000,
        0x00FE0001,
        0x00FE01FE,
        0x00FE01FF,
        0x00FE0100,
        0x00FE0101,
        0x00FFFEFE,
        0x00FFFEFF,
        0x00FFFE00,
        0x00FFFE01,
        0x00FFFFFE,
        0x00FFFFFF,
        0x00FFFF00,
        0x00FFFF01,
        0x00FF00FE,
        0x00FF00FF,
        0x00FF0000,
        0x00FF0001,
        0x00FF01FE,
        0x00FF01FF,
        0x00FF0100,
        0x00FF0101,
        0x0000FEFE,
        0x0000FEFF,
        0x0000FE00,
        0x0000FE01,
        0x0000FFFE,
        0x0000FFFF,
        0x0000FF00,
        0x0000FF01,
        0x000000FE,
        0x000000FF,
        0x00000000,
        0x00000001,
        0x000001FE,
        0x000001FF,
        0x00000100,
        0x00000101,
        0x0001FEFE,
        0x0001FEFF,
        0x0001FE00,
        0x0001FE01,
        0x0001FFFE,
        0x0001FFFF,
        0x0001FF00,
        0x0001FF01,
        0x000100FE,
        0x000100FF,
        0x00010000,
        0x00010001,
        0x000101FE,
        0x000101FF,
        0x00010100,
        0x00010101,
        0x01FEFEFE,
        0x01FEFEFF,
        0x01FEFE00,
        0x01FEFE01,
        0x01FEFFFE,
        0x01FEFFFF,
        0x01FEFF00,
        0x01FEFF01,
        0x01FE00FE,
        0x01FE00FF,
        0x01FE0000,
        0x01FE0001,
        0x01FE01FE,
        0x01FE01FF,
        0x01FE0100,
        0x01FE0101,
        0x01FFFEFE,
        0x01FFFEFF,
        0x01FFFE00,
        0x01FFFE01,
        0x01FFFFFE,
        0x01FFFFFF,
        0x01FFFF00,
        0x01FFFF01,
        0x01FF00FE,
        0x01FF00FF,
        0x01FF0000,
        0x01FF0001,
        0x01FF01FE,
        0x01FF01FF,
        0x01FF0100,
        0x01FF0101,
        0x0100FEFE,
        0x0100FEFF,
        0x0100FE00,
        0x0100FE01,
        0x0100FFFE,
        0x0100FFFF,
        0x0100FF00,
        0x0100FF01,
        0x010000FE,
        0x010000FF,
        0x01000000,
        0x01000001,
        0x010001FE,
        0x010001FF,
        0x01000100,
        0x01000101,
        0x0101FEFE,
        0x0101FEFF,
        0x0101FE00,
        0x0101FE01,
        0x0101FFFE,
        0x0101FFFF,
        0x0101FF00,
        0x0101FF01,
        0x010100FE,
        0x010100FF,
        0x01010000,
        0x01010001,
        0x010101FE,
        0x010101FF,
        0x01010100,
        0x01010101);
    fn LoadDequantizationTable(local_idx:u32)
    {
        // Move dequantization table into on chip memory.
        shm_dequantization_table[local_idx] = q2_dequantization_table[local_idx];
    }
    fn DequantizedFrom2BitsTo8Bits(in: u32) -> vec4<u32>
    {
        let unpacked = unpack4xU8(in);
        return vec4<u32>(shm_dequantization_table[unpacked[0]],
            shm_dequantization_table[unpacked[1]],
            shm_dequantization_table[unpacked[2]],
            shm_dequantization_table[unpacked[3]]);
    }
#endif

#if has_zero_points && n_bits == 8
    // If has_zero_points is true, vec4<i32>(unpack4xU8(b_data)) - vec4<i32>(zero) may be out of the range [-128, 127] since zero can be any value between [0, 255].
    // To avoid the data overflow when use pack4xI8, we still use |pack4xI8(vec4<i32>(unpack4xU8(xxx)) - vec4<i32>(128))| to process the b data. In SDP8AI, we use the
    // dp4a's result of a and b to subtract dot(vec4<i32>(unpack4xI8(a)), vec4<i32>(zero - 128)) to get the correct result.
    // Scaled dot product of 8 packed unsigned integers.
    fn SDP8AI(a1:vec4<u32>, b1:vec4<u32>, a2:vec4<u32>, b2:vec4<u32>, scale:output_element_t, zero: i32) -> output_element_t
    {
        let bias_zero = zero - 128;
        var local_sum = dot4I8Packed(a1[0], b1[0]);
        var dequantized_a_sum = vec4<i32>(unpack4xI8(a1[0]));
        local_sum += dot4I8Packed(a1[1], b1[1]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a1[1]));
        local_sum += dot4I8Packed(a1[2], b1[2]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a1[2]));
        local_sum += dot4I8Packed(a1[3], b1[3]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a1[3]));
        local_sum += dot4I8Packed(a2[0], b2[0]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a2[0]));
        local_sum += dot4I8Packed(a2[1], b2[1]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a2[1]));
        local_sum += dot4I8Packed(a2[2], b2[2]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a2[2]));
        local_sum += dot4I8Packed(a2[3], b2[3]);
        dequantized_a_sum += vec4<i32>(unpack4xI8(a2[3]));
        local_sum -= dot(dequantized_a_sum, vec4<i32>(bias_zero));
        return output_element_t(mul_precision(local_sum) * mul_precision(scale));
    }
#else
    // Scaled dot product of 8 packed unsigned integers.
    fn SDP8AI(a1:vec4<u32>, b1:vec4<u32>, a2:vec4<u32>, b2:vec4<u32>, scale:output_element_t) -> output_element_t
    {
        var local_sum = dot4I8Packed(a1[0], b1[0]);
        local_sum += dot4I8Packed(a1[1], b1[1]);
        local_sum += dot4I8Packed(a1[2], b1[2]);
        local_sum += dot4I8Packed(a1[3], b1[3]);
        local_sum += dot4I8Packed(a2[0], b2[0]);
        local_sum += dot4I8Packed(a2[1], b2[1]);
        local_sum += dot4I8Packed(a2[2], b2[2]);
        local_sum += dot4I8Packed(a2[3], b2[3]);
        return output_element_t(mul_precision(local_sum) * mul_precision(scale));
    }
#endif
