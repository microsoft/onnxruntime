#param has_zero_points
#param output_type
#param n_bits

#if has_zero_points
const elements_in_uint32:u32 = 32u / n_bits;

fn mm_read_zero(row : u32, col : u32, r_dim: u32, c_dim: u32) -> output_type
{
  if (row < r_dim && col < c_dim) {
    let offset = row * c_dim + col;

    // u32 holds elements_in_uint32 packed nbits.
    let array_index = offset / elements_in_uint32;
    let component_index = offset % elements_in_uint32;
    let packed_value = zero_points[array_index];

    // Extract the nbits component
    let shift_amount = component_index * n_bits;

    let masked_value = (packed_value >> shift_amount) & (n_bits == 4 ? "0xFu" : "0xFF");
    return output_type(masked_value);
  }
  return output_type(0);
}
#else
const default_zero_point = n_bits == 4 ? 8 : 128;
fn mm_read_zero(row : u32, col : u32, r_dim: u32, c_dim: u32) -> output_type {
  return output_type(default_zero_point);
}
#endif
