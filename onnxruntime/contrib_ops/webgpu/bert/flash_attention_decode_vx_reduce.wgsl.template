// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#param tile_size

// Inputs are splits of the GQA output, split into num_total_seq_length_tiles
// rows. This shader needs to add these splits across the row dimension to
// arrive at the final result. The column is head size wide. The reduction
// achieves maximum parallelization by splitting this task first into tile_size
// columns that each workgroup is responsible for. Then within each workgroup
// the task of summation over the num_total_seq_length_tile for the tile_size
// columns is further split in two ways. First across the row dimension to have
// WORKGROUP_SIZE/TILE_SIZE parallel computations of summation of TILE_SIZE
// rows. Then across the column dimension where each thread is responsible for 1
// column of the TILE_SIZE columns the workgroup is responsible for.

var<workgroup> tile_input: array<array<output_value_t, tile_size>, tile_size>;

$MAIN {
  let head_size_offset = (workgroup_idx % uniforms.num_head_size_tile) * tile_size;
  let head_idx = u32(workgroup_idx / uniforms.num_head_size_tile);
  let in_offset = head_idx * uniforms.num_present_sequence_length_tile * uniforms.head_size_vec;
  var value = output_value_t(0);
  let local_row = u32(local_idx / tile_size);
  let local_col = local_idx % tile_size;

  if (head_size_offset + local_col < uniforms.head_size_vec) {
    for (var r = 0u; r < uniforms.num_total_seq_length_tile; r += tile_size) {
      if (r + local_row < uniforms.num_total_seq_length_tile) {
        value += input[in_offset + (r + local_row) * uniforms.head_size_vec + head_size_offset + local_col];
      }
    }
  }

  tile_input[local_row][local_col] = value;
  workgroupBarrier();

  if (head_idx >= uniforms.num_heads) {
    return;
  }

  if (local_idx < tile_size && head_size_offset + local_idx < uniforms.head_size_vec) {
    value = output_value_t(0);
    for (var i = 0u; i < tile_size; i++) {
      value += tile_input[i][local_idx];
    }
    let output_id = head_idx * uniforms.head_size_vec + head_size_offset + local_idx;
    output[output_id] = value;
  }
}
