// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

#param tile_size
#param head_size_vec
#param tile_size_k_vec
#param sub_tile_count
#param use_indirect_dispatch

// Note that this shader adopts similar algorithm with dp4a generation shader.
//
// This algorithm works to compute dot product of v with qk parallelly, by
// processing on the head_size dimension at each step amongst tile_size_k_vec
// threads, and utilizing the remaining threads in the workgroup to process
// additional rows of |present_value| in parallel (such that the values in
// shared memory (tile_qk) for |qk| can be reused). The tile_size_k_vec threads
// also reload |present_value| tile_size/sub_tile_count times to compute partial
// dot products of other |present_value| rows in order to complete all tile_size
// |present_value| rows in this workgroup and also reusing the values in
// tile_qk.
//
// The difference with FlashAttentionDecodeQKTProgram is that the dot products
// go through the rows (total_sequence_length) of |present_value| instead of
// columns (head_size_vec). And each workgroup only calculate current
// tile_size's dot products instead of iterating the whole row
// |total_sequence_length|. That's why this shader is a split shader. The final
// reduce will be done in FlashAttentionDecodeReduceProgram.

// TODO: Ideally, there should only be two shaders FlashAttentionDecodeSplitVx
// and FlashAttentionDecodeVxReduce, which can also reduce the intermediate
// memory. The FlashAttentionDecodeQKT can be merged into split shader and do
// the final softmax adjustment in the reduce shader. However, some issues are
// met that when the total sequence length exceeds some value, the result will
// become garbage. Since it can't be resolved in a short time, leave it as TODO
// to fix it in future.

var<workgroup> tile_qk: array<present_value_element_t, tile_size>;
var<workgroup> tile_output: array<present_value_value_t, head_size_vec>;
var<workgroup> qkv_values: array<array<present_value_value_t, tile_size_k_vec>, sub_tile_count>;

$MAIN {
  let local_row = u32(local_idx / tile_size_k_vec);
  let local_col = local_idx % tile_size_k_vec;
  #if use_indirect_dispatch
  let total_sequence_length = u32(seqlens_k[0]) + 1u;
  #else
  let total_sequence_length = uniforms.total_sequence_length;
  #endif
  let num_total_seq_length_tile = (total_sequence_length + tile_size - 1) / tile_size;
  let total_seq_offset = (workgroup_idx % num_total_seq_length_tile) * tile_size;
  let head_idx = u32(workgroup_idx / num_total_seq_length_tile);
  let present_offset = u32(head_idx / uniforms.n_reps) * head_size_vec * uniforms.present_sequence_length;

  // Calculate the global max and sum in qk.
  if (head_idx < uniforms.num_heads)
  {
    var g_max = f32(-3.402823e+38f);
    var g_sum = f32(0);
    for (var i = 0u; i < num_total_seq_length_tile; i++)
    {
      let meta_offset = head_idx * uniforms.num_present_sequence_length_tile + i;
      g_max = max(g_max, metadata[meta_offset].x);
    }
    for (var i = 0u; i < num_total_seq_length_tile; i++)
    {
      let meta_offset = head_idx * uniforms.num_present_sequence_length_tile + i;
      let m_value = metadata[meta_offset];
      g_sum += exp(m_value.x - g_max) * m_value.y;
    }

    if (total_seq_offset + local_idx < total_sequence_length) {
      tile_qk[local_idx] = present_value_element_t(exp(f32(qk[head_idx * uniforms.present_sequence_length + total_seq_offset + local_idx]) - g_max) / g_sum);
    }
  }
  for (var k: u32 = 0u; k < head_size_vec; k += tile_size_k_vec) {
    var value = present_value_value_t(0);
    qkv_values[local_row][local_col] = present_value_value_t(0);
    workgroupBarrier();

    if (k + local_col < head_size_vec) {
      for (var row_offset = 0u; row_offset < tile_size; row_offset += sub_tile_count) {
        if (total_seq_offset + row_offset + local_row < total_sequence_length) {
          value += present_value[present_offset + (total_seq_offset + row_offset + local_row) * head_size_vec + k + local_col] * tile_qk[row_offset + local_row];
        }
      }
    }

    qkv_values[local_row][local_col] = value;
    workgroupBarrier();

    if (local_idx < tile_size_k_vec) {
      for (var i = 0u; i < sub_tile_count; i++) {
        tile_output[k + local_idx] += qkv_values[i][local_idx];
      }
    }
    workgroupBarrier();
  }

  if (head_idx >= uniforms.num_heads) {
    return;
  }

  for (var i = local_idx; i < head_size_vec; i += workgroup_size_x) {
    let out_offset = head_idx * uniforms.num_present_sequence_length_tile * head_size_vec + (workgroup_idx % num_total_seq_length_tile) * head_size_vec + i;
    out_split_vx[out_offset] = tile_output[i];
  }
}
