#param tile_size
#param head_size_vec
#param tile_size_k_vec
#param sub_tile_count

var<workgroup> tile_qk: array<present_value_element_t, tile_size>;
var<workgroup> tile_output: array<present_value_value_t, head_size_vec>;
var<workgroup> qkv_values: array<array<present_value_value_t, tile_size_k_vec>, sub_tile_count>;

$MAIN {
  let local_row = u32(local_idx / tile_size_k_vec);
  let local_col = local_idx % tile_size_k_vec;
  let total_seq_offset = (workgroup_idx % uniforms.num_total_seq_length_tile) * tile_size;
  let head_idx = u32(workgroup_idx / uniforms.num_total_seq_length_tile);
  var total_sequence_length = uniforms.total_sequence_length;
  let present_offset = u32(head_idx / uniforms.n_reps) * head_size_vec * uniforms.present_sequence_length;

  // Calculate the global max and sum in qk.
  if (head_idx < uniforms.num_heads)
  {
    var g_max = f32(-3.402823e+38f);
    var g_sum = f32(0);
    for (var i = 0u; i < uniforms.num_total_seq_length_tile; i++)
    {
      let meta_offset = head_idx * uniforms.num_present_sequence_length_tile + i;
      g_max = max(g_max, metadata[meta_offset].x);
    }
    for (var i = 0u; i < uniforms.num_total_seq_length_tile; i++)
    {
      let meta_offset = head_idx * uniforms.num_present_sequence_length_tile + i;
      let m_value = metadata[meta_offset];
      g_sum += exp(m_value.x - g_max) * m_value.y;
    }

    if (total_seq_offset + local_idx < total_sequence_length) {
      tile_qk[local_idx] = present_value_element_t(exp(f32(qk[head_idx * uniforms.present_sequence_length + total_seq_offset + local_idx]) - g_max) / g_sum);
    }
  }
  for (var k: u32 = 0u; k < head_size_vec; k += tile_size_k_vec) {
    var value = present_value_value_t(0);
    qkv_values[local_row][local_col] = present_value_value_t(0);
    workgroupBarrier();

    if (k + local_col < head_size_vec) {
      for (var row_offset = 0u; row_offset < tile_size; row_offset += sub_tile_count) {
        if (total_seq_offset + row_offset + local_row < total_sequence_length) {
          value += present_value[present_offset + (total_seq_offset + row_offset + local_row) * head_size_vec + k + local_col] * tile_qk[row_offset + local_row];
        }
      }
    }

    qkv_values[local_row][local_col] = value;
    workgroupBarrier();

    if (local_idx < tile_size_k_vec) {
      for (var i = 0u; i < sub_tile_count; i++) {
        tile_output[k + local_idx] += qkv_values[i][local_idx];
      }
    }
    workgroupBarrier();
  }

  if (head_idx >= uniforms.num_heads) {
    return;
  }

  for (var i = local_idx; i < head_size_vec; i += workgroup_size_x) {
    let out_offset = head_idx * uniforms.num_present_sequence_length_tile * head_size_vec + (workgroup_idx % uniforms.num_total_seq_length_tile) * head_size_vec + i;
    out_split_vx[out_offset] = tile_output[i];
  }
}
