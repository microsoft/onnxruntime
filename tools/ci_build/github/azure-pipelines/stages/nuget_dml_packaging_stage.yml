parameters:
- name: DoEsrp
  type: boolean
  default: true

stages:
- stage: NuGet_Packaging_DML
  dependsOn:
  - Windows_CI_GPU_DML_Dev
  - Windows_CI_GPU_DML_Dev_arm64
  condition: succeeded()
  jobs:
  - job: NuGet_Packaging_DML
    workspace:
      clean: all
    pool:
      name: 'onnxruntime-Win2022-GPU-dml-A10'
      os: windows
      templateContext:
        inputs:
        - input: pipelineArtifact
          artifactName: drop-nuget-dml
          targetPath: '$(Build.BinariesDirectory)/nuget-artifact-dml'
        - input: pipelineArtifact
          artifactName: drop-win-dml-arm64-zip
          targetPath: '$(Build.BinariesDirectory)/nuget-artifact-dml'
        outputs:
          - ${{if and(eq(parameters.IsReleaseBuild, false), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/users/snnn/')))}}:
            - output: nuget
              # condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main')) # Optional condition
              useDotNetTask: false # The default is false to use the NuGetCommand task. Set to true to use the DotNetCoreCLI task to publish packages.
              packagesToPush: '$(Build.ArtifactStagingDirectory)/*.nupkg'
              packageParentPath: '$(Build.ArtifactStagingDirectory)/'
              publishVstsFeed: PublicPackages/ORT-Nightly  # Required when pushing to internal feed.
              nuGetFeedType: internal  # Change to external when publishing to external feed
              allowPackageConflicts: true # Optional. NuGetCommand task only.
              publishPackageMetadata: true # Optional
          - ${{ else }}:
            - output: pipelineArtifact
              targetPath: $(Build.ArtifactStagingDirectory)
              artifactName: 'packages"
    steps:
    - powershell: |
        # Define the working directory and the path to 7-Zip
        $workingDir = "$(Build.BinariesDirectory)\nuget-artifact-dml"
        $sevenZipPath = "C:\Program Files\7-Zip\7z.exe" # Standard installation path for 7-Zip

        Write-Host "Setting location to $workingDir"
        Set-Location -Path $workingDir

        # Unzip the supplemental ARM64 binaries needed for the packages.
        # This is done once to avoid unzipping it inside the loop.
        $arm64ZipFile = "win-dml-arm64.zip"
        $arm64ExtractPath = "win-dml-arm64-unzipped"
        Write-Host "Extracting $arm64ZipFile to $arm64ExtractPath"
        & $sevenZipPath x $arm64ZipFile -o"$arm64ExtractPath" -y

        # Find all non-managed .nupkg files.
        $nupkgFiles = Get-ChildItem -Path . -Recurse -Filter *.nupkg | Where-Object { $_.Name -notlike "*Managed*" }

        # Verify that exactly one non-managed package was found. If not, fail the build.
        if ($nupkgFiles.Count -ne 1) {
            Write-Error "Error: Expected to find exactly one non-managed NuGet package, but found $($nupkgFiles.Count)."
            exit 1
        }

        # Get the single package to process.
        $nupkg = $nupkgFiles[0]

        # Verify the package name matches the expected pattern. If not, fail the build.
        if ($nupkg.Name -notlike "Microsoft.ML.OnnxRuntime.DirectML*.nupkg") {
            Write-Error "Error: Package name '$($nupkg.Name)' does not match the expected pattern 'Microsoft.ML.OnnxRuntime.DirectML*.nupkg'."
            exit 1
        }

        Write-Host "---"
        Write-Host "Processing package: $($nupkg.FullName)"

        # Create a temporary directory for package modification
        $tempDir = Join-Path $nupkg.DirectoryName ($nupkg.BaseName + "_temp")
        if (Test-Path $tempDir) {
            Remove-Item -Recurse -Force $tempDir
        }
        New-Item -ItemType Directory -Path $tempDir | Out-Null

        # 1. Extract the original nupkg to the temporary directory
        Write-Host "Extracting $($nupkg.Name) to $tempDir"
        & $sevenZipPath x $nupkg.FullName -o"$tempDir" -y

        # 2. Define the new runtime path and create it
        $newRuntimePath = Join-Path $tempDir "runtimes\win-arm64\native"
        New-Item -ItemType Directory -Path $newRuntimePath -Force | Out-Null

        # 3. Copy the required ARM64 binaries into the new structure
        $arm64SourcePath = Join-Path $workingDir "$arm64ExtractPath\runtimes\win-arm64\native"
        Write-Host "Copying ARM64 binaries to $newRuntimePath"
        Copy-Item -Path "$arm64SourcePath\*" -Destination $newRuntimePath -Recurse -Force

        # 4. Delete the original nupkg file before creating the new one
        Remove-Item -Path $nupkg.FullName -Force

        # 5. Re-compress the contents of the temp directory back into a new nupkg file.
        # We use Push-Location to change into the temp directory so the zip paths are relative.
        Write-Host "Creating new nupkg file at $($nupkg.FullName)"
        Push-Location $tempDir
        & $sevenZipPath a -tzip "$($nupkg.FullName)" ".\" -r
        Pop-Location

        # 6. Clean up the temporary directory
        Write-Host "Cleaning up temporary directory $tempDir"
        Remove-Item -Recurse -Force $tempDir
        Write-Host "Finished processing $($nupkg.Name)"

        # Clean up the unzipped ARM64 binaries directory
        Write-Host "---"
        Write-Host "Cleaning up temporary ARM64 directory."
        Remove-Item -Recurse -Force $arm64ExtractPath

        # Copy the final, modified NuGet packages to the artifact staging directory
        Write-Host "Copying final artifacts to $(Build.ArtifactStagingDirectory)"
        Copy-Item -Path (Join-Path $workingDir "Microsoft.ML.OnnxRuntime.DirectML*.nupkg") -Destination "$(Build.ArtifactStagingDirectory)" -Force
      displayName: 'Bundle DML NuGet and other binaries (PowerShell)'

    - template: ../templates/esrp_nuget.yml
      parameters:
        DisplayName: 'ESRP - sign NuGet package'
        FolderPath: '$(Build.ArtifactStagingDirectory)'
        DoEsrp: ${{ parameters.DoEsrp }}
